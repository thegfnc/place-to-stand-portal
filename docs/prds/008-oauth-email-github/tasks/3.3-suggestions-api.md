# Task 3.3: Suggestions API

## Overview
Create API endpoints for listing, approving, rejecting, and managing task suggestions.

## Dependencies
- Task 3.2 (Email Analysis AI)

## Deliverables

### 1. Create `/lib/data/suggestions/index.ts`

```typescript
import { eq, and, isNull, desc, sql, inArray } from 'drizzle-orm'
import { db } from '@/lib/db'
import {
  taskSuggestions,
  suggestionFeedback,
  emailMetadata,
  projects,
  tasks,
} from '@/lib/db/schema'
import { logActivity } from '@/lib/activity/logger'
import type {
  TaskSuggestion,
  TaskSuggestionWithEmail,
  NewSuggestionFeedback,
} from '@/lib/types/suggestions'

/**
 * Get pending suggestions for review
 */
export async function getPendingSuggestions(
  options: { limit?: number; projectId?: string } = {}
): Promise<TaskSuggestionWithEmail[]> {
  const { limit = 50, projectId } = options

  const conditions = [
    eq(taskSuggestions.status, 'PENDING'),
    isNull(taskSuggestions.deletedAt),
  ]

  if (projectId) {
    conditions.push(eq(taskSuggestions.projectId, projectId))
  }

  const results = await db
    .select({
      suggestion: taskSuggestions,
      email: {
        id: emailMetadata.id,
        subject: emailMetadata.subject,
        fromEmail: emailMetadata.fromEmail,
        fromName: emailMetadata.fromName,
        receivedAt: emailMetadata.receivedAt,
      },
      project: {
        id: projects.id,
        name: projects.name,
      },
    })
    .from(taskSuggestions)
    .innerJoin(emailMetadata, eq(emailMetadata.id, taskSuggestions.emailMetadataId))
    .leftJoin(projects, eq(projects.id, taskSuggestions.projectId))
    .where(and(...conditions))
    .orderBy(desc(taskSuggestions.createdAt))
    .limit(limit)

  return results.map(r => ({
    ...r.suggestion,
    email: r.email,
    project: r.project,
  }))
}

/**
 * Get a single suggestion by ID
 */
export async function getSuggestionById(
  suggestionId: string
): Promise<TaskSuggestionWithEmail | null> {
  const [result] = await db
    .select({
      suggestion: taskSuggestions,
      email: {
        id: emailMetadata.id,
        subject: emailMetadata.subject,
        fromEmail: emailMetadata.fromEmail,
        fromName: emailMetadata.fromName,
        receivedAt: emailMetadata.receivedAt,
      },
      project: {
        id: projects.id,
        name: projects.name,
      },
    })
    .from(taskSuggestions)
    .innerJoin(emailMetadata, eq(emailMetadata.id, taskSuggestions.emailMetadataId))
    .leftJoin(projects, eq(projects.id, taskSuggestions.projectId))
    .where(
      and(
        eq(taskSuggestions.id, suggestionId),
        isNull(taskSuggestions.deletedAt)
      )
    )
    .limit(1)

  if (!result) return null

  return {
    ...result.suggestion,
    email: result.email,
    project: result.project,
  }
}

/**
 * Approve a suggestion and create a task
 */
export async function approveSuggestion(
  suggestionId: string,
  userId: string,
  modifications?: {
    title?: string
    description?: string
    projectId?: string
    dueDate?: string
    priority?: string
  }
): Promise<{ task: typeof tasks.$inferSelect }> {
  const suggestion = await getSuggestionById(suggestionId)

  if (!suggestion) {
    throw new Error('Suggestion not found')
  }

  if (suggestion.status !== 'PENDING') {
    throw new Error('Suggestion already processed')
  }

  // Determine final values
  const finalTitle = modifications?.title ?? suggestion.suggestedTitle
  const finalDescription = modifications?.description ?? suggestion.suggestedDescription
  const finalProjectId = modifications?.projectId ?? suggestion.projectId
  const finalDueDate = modifications?.dueDate ?? suggestion.suggestedDueDate

  if (!finalProjectId) {
    throw new Error('Project is required')
  }

  // Record feedback for any modifications
  const feedbackRecords: NewSuggestionFeedback[] = []

  if (modifications?.title && modifications.title !== suggestion.suggestedTitle) {
    feedbackRecords.push({
      taskSuggestionId: suggestionId,
      feedbackType: 'title_changed',
      originalValue: suggestion.suggestedTitle,
      correctedValue: modifications.title,
      createdBy: userId,
    })
  }

  if (modifications?.description && modifications.description !== suggestion.suggestedDescription) {
    feedbackRecords.push({
      taskSuggestionId: suggestionId,
      feedbackType: 'description_changed',
      originalValue: suggestion.suggestedDescription || '',
      correctedValue: modifications.description,
      createdBy: userId,
    })
  }

  if (modifications?.projectId && modifications.projectId !== suggestion.projectId) {
    feedbackRecords.push({
      taskSuggestionId: suggestionId,
      feedbackType: 'project_changed',
      originalValue: suggestion.projectId || '',
      correctedValue: modifications.projectId,
      createdBy: userId,
    })
  }

  // Create task and update suggestion in transaction
  const result = await db.transaction(async tx => {
    // Create the task
    const [newTask] = await tx
      .insert(tasks)
      .values({
        projectId: finalProjectId,
        title: finalTitle,
        description: finalDescription,
        dueOn: finalDueDate,
        status: 'BACKLOG',
        createdBy: userId,
        updatedBy: userId,
      })
      .returning()

    // Update suggestion status
    await tx
      .update(taskSuggestions)
      .set({
        status: modifications ? 'MODIFIED' : 'APPROVED',
        reviewedBy: userId,
        reviewedAt: new Date().toISOString(),
        createdTaskId: newTask.id,
        updatedAt: new Date().toISOString(),
      })
      .where(eq(taskSuggestions.id, suggestionId))

    // Record feedback
    if (feedbackRecords.length > 0) {
      await tx.insert(suggestionFeedback).values(feedbackRecords)
    }

    return { task: newTask }
  })

  // Log activity
  await logActivity({
    actorId: userId,
    actorRole: 'ADMIN',
    verb: 'TASK_CREATED_FROM_EMAIL',
    summary: `Created task "${finalTitle}" from email suggestion`,
    targetType: 'TASK',
    targetId: result.task.id,
    targetProjectId: finalProjectId,
    metadata: {
      suggestionId,
      emailId: suggestion.emailMetadataId,
      wasModified: !!modifications,
    },
  })

  return result
}

/**
 * Reject a suggestion
 */
export async function rejectSuggestion(
  suggestionId: string,
  userId: string,
  reason?: string
): Promise<void> {
  const suggestion = await getSuggestionById(suggestionId)

  if (!suggestion) {
    throw new Error('Suggestion not found')
  }

  if (suggestion.status !== 'PENDING') {
    throw new Error('Suggestion already processed')
  }

  await db.transaction(async tx => {
    await tx
      .update(taskSuggestions)
      .set({
        status: 'REJECTED',
        reviewedBy: userId,
        reviewedAt: new Date().toISOString(),
        reviewNotes: reason,
        updatedAt: new Date().toISOString(),
      })
      .where(eq(taskSuggestions.id, suggestionId))

    // Record feedback
    if (reason) {
      await tx.insert(suggestionFeedback).values({
        taskSuggestionId: suggestionId,
        feedbackType: 'rejected',
        originalValue: suggestion.suggestedTitle,
        correctedValue: reason,
        createdBy: userId,
      })
    }
  })

  await logActivity({
    actorId: userId,
    actorRole: 'ADMIN',
    verb: 'TASK_SUGGESTION_REJECTED',
    summary: `Rejected task suggestion "${suggestion.suggestedTitle}"`,
    targetType: 'TASK',
    targetId: suggestionId,
    metadata: { reason },
  })
}

/**
 * Get suggestion counts by status
 */
export async function getSuggestionCounts(): Promise<{
  pending: number
  approved: number
  rejected: number
}> {
  const results = await db
    .select({
      status: taskSuggestions.status,
      count: sql<number>`count(*)::int`,
    })
    .from(taskSuggestions)
    .where(isNull(taskSuggestions.deletedAt))
    .groupBy(taskSuggestions.status)

  const counts = { pending: 0, approved: 0, rejected: 0 }
  for (const r of results) {
    if (r.status === 'PENDING') counts.pending = r.count
    if (r.status === 'APPROVED' || r.status === 'MODIFIED') counts.approved += r.count
    if (r.status === 'REJECTED') counts.rejected = r.count
  }

  return counts
}
```

### 2. Create `/app/api/suggestions/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { requireRole } from '@/lib/auth/session'
import { getPendingSuggestions, getSuggestionCounts } from '@/lib/data/suggestions'

export async function GET(request: NextRequest) {
  await requireRole('ADMIN')

  const { searchParams } = request.nextUrl
  const projectId = searchParams.get('projectId') || undefined
  const limit = parseInt(searchParams.get('limit') || '50', 10)

  const [suggestions, counts] = await Promise.all([
    getPendingSuggestions({ limit, projectId }),
    getSuggestionCounts(),
  ])

  return NextResponse.json({ suggestions, counts })
}
```

### 3. Create `/app/api/suggestions/[suggestionId]/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { requireRole } from '@/lib/auth/session'
import { getSuggestionById } from '@/lib/data/suggestions'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ suggestionId: string }> }
) {
  await requireRole('ADMIN')
  const { suggestionId } = await params

  const suggestion = await getSuggestionById(suggestionId)

  if (!suggestion) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  return NextResponse.json(suggestion)
}
```

### 4. Create `/app/api/suggestions/[suggestionId]/approve/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'
import { requireRole } from '@/lib/auth/session'
import { approveSuggestion } from '@/lib/data/suggestions'

const approveSchema = z.object({
  title: z.string().min(1).max(200).optional(),
  description: z.string().max(2000).optional(),
  projectId: z.string().uuid().optional(),
  dueDate: z.string().date().optional(),
  priority: z.enum(['HIGH', 'MEDIUM', 'LOW']).optional(),
})

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ suggestionId: string }> }
) {
  const user = await requireRole('ADMIN')
  const { suggestionId } = await params

  const body = await request.json().catch(() => ({}))
  const modifications = approveSchema.parse(body)

  try {
    const result = await approveSuggestion(
      suggestionId,
      user.id,
      Object.keys(modifications).length > 0 ? modifications : undefined
    )

    return NextResponse.json({
      success: true,
      task: result.task,
    })
  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to approve' },
      { status: 400 }
    )
  }
}
```

### 5. Create `/app/api/suggestions/[suggestionId]/reject/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'
import { requireRole } from '@/lib/auth/session'
import { rejectSuggestion } from '@/lib/data/suggestions'

const rejectSchema = z.object({
  reason: z.string().max(500).optional(),
})

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ suggestionId: string }> }
) {
  const user = await requireRole('ADMIN')
  const { suggestionId } = await params

  const body = await request.json().catch(() => ({}))
  const { reason } = rejectSchema.parse(body)

  try {
    await rejectSuggestion(suggestionId, user.id, reason)
    return NextResponse.json({ success: true })
  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to reject' },
      { status: 400 }
    )
  }
}
```

### 6. Create `/app/api/suggestions/bulk/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'
import { requireRole } from '@/lib/auth/session'
import { approveSuggestion, rejectSuggestion } from '@/lib/data/suggestions'

const bulkSchema = z.object({
  action: z.enum(['approve', 'reject']),
  suggestionIds: z.array(z.string().uuid()).min(1).max(50),
  reason: z.string().max(500).optional(), // For rejections
})

export async function POST(request: NextRequest) {
  const user = await requireRole('ADMIN')

  const body = await request.json()
  const { action, suggestionIds, reason } = bulkSchema.parse(body)

  const results: Array<{ id: string; success: boolean; error?: string }> = []

  for (const id of suggestionIds) {
    try {
      if (action === 'approve') {
        await approveSuggestion(id, user.id)
      } else {
        await rejectSuggestion(id, user.id, reason)
      }
      results.push({ id, success: true })
    } catch (error) {
      results.push({
        id,
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      })
    }
  }

  return NextResponse.json({
    processed: results.length,
    succeeded: results.filter(r => r.success).length,
    failed: results.filter(r => !r.success).length,
    results,
  })
}
```

## Acceptance Criteria

- [ ] List pending suggestions with email context
- [ ] Get single suggestion by ID
- [ ] Approve suggestion creates task
- [ ] Approve with modifications records feedback
- [ ] Reject suggestion updates status
- [ ] Bulk approve/reject multiple suggestions
- [ ] Activity logged for all actions
- [ ] Count endpoint for dashboard badges
- [ ] Error handling for invalid states

## Files Changed
- `lib/data/suggestions/index.ts` (new)
- `app/api/suggestions/route.ts` (new)
- `app/api/suggestions/[suggestionId]/route.ts` (new)
- `app/api/suggestions/[suggestionId]/approve/route.ts` (new)
- `app/api/suggestions/[suggestionId]/reject/route.ts` (new)
- `app/api/suggestions/bulk/route.ts` (new)

## Testing

```bash
# List pending suggestions
curl http://localhost:3000/api/suggestions

# Approve with modifications
curl -X POST http://localhost:3000/api/suggestions/{id}/approve \
  -H "Content-Type: application/json" \
  -d '{"title": "Updated title", "projectId": "..."}'

# Reject
curl -X POST http://localhost:3000/api/suggestions/{id}/reject \
  -H "Content-Type: application/json" \
  -d '{"reason": "Not actionable"}'
```

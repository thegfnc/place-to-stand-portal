# Task 3.1: Task Suggestions Database Schema

## Overview
Add database tables for storing AI-generated task suggestions from email analysis, with support for human review workflow.

## Dependencies
- Task 2.3 (Email Metadata Schema)

## Deliverables

### 1. Add enum to `/lib/db/schema.ts`

```typescript
export const suggestionStatus = pgEnum('suggestion_status', [
  'PENDING',   // Awaiting user review
  'APPROVED',  // User approved, task created
  'REJECTED',  // User rejected
  'MODIFIED',  // User approved with modifications
  'EXPIRED',   // Auto-expired after X days
])
```

### 2. Add `taskSuggestions` table to `/lib/db/schema.ts`

```typescript
export const taskSuggestions = pgTable(
  'task_suggestions',
  {
    id: uuid().defaultRandom().primaryKey().notNull(),
    emailMetadataId: uuid('email_metadata_id').notNull(),
    projectId: uuid('project_id'), // Suggested project (can be overridden)
    suggestedTitle: text('suggested_title').notNull(),
    suggestedDescription: text('suggested_description'),
    suggestedDueDate: date('suggested_due_date'),
    suggestedPriority: text('suggested_priority'), // HIGH, MEDIUM, LOW
    suggestedAssignees: uuid('suggested_assignees').array().default([]),
    confidence: numeric({ precision: 3, scale: 2 }).notNull(), // 0.00-1.00 (CHECK constraint enforces range)
    reasoning: text(), // AI's explanation for the suggestion
    status: suggestionStatus().default('PENDING').notNull(),
    reviewedBy: uuid('reviewed_by'),
    reviewedAt: timestamp('reviewed_at', { withTimezone: true, mode: 'string' }),
    reviewNotes: text('review_notes'),
    createdTaskId: uuid('created_task_id'), // Link to created task if approved
    aiModelVersion: text('ai_model_version'),
    promptTokens: integer('prompt_tokens'),
    completionTokens: integer('completion_tokens'),
    createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' })
      .default(sql`timezone('utc'::text, now())`)
      .notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true, mode: 'string' })
      .default(sql`timezone('utc'::text, now())`)
      .notNull(),
    deletedAt: timestamp('deleted_at', { withTimezone: true, mode: 'string' }),
  },
  table => [
    // Index for pending suggestions (main query)
    index('idx_task_suggestions_pending')
      .using('btree', table.status.asc().nullsLast())
      .where(sql`(deleted_at IS NULL AND status = 'PENDING')`),
    // Index for email lookup
    index('idx_task_suggestions_email')
      .using('btree', table.emailMetadataId.asc().nullsLast().op('uuid_ops'))
      .where(sql`(deleted_at IS NULL)`),
    // Index for project lookup
    index('idx_task_suggestions_project')
      .using('btree', table.projectId.asc().nullsLast().op('uuid_ops'))
      .where(sql`(deleted_at IS NULL AND project_id IS NOT NULL)`),
    // Foreign keys
    foreignKey({
      columns: [table.emailMetadataId],
      foreignColumns: [emailMetadata.id],
      name: 'task_suggestions_email_metadata_id_fkey',
    }).onDelete('cascade'),
    foreignKey({
      columns: [table.projectId],
      foreignColumns: [projects.id],
      name: 'task_suggestions_project_id_fkey',
    }),
    foreignKey({
      columns: [table.reviewedBy],
      foreignColumns: [users.id],
      name: 'task_suggestions_reviewed_by_fkey',
    }),
    foreignKey({
      columns: [table.createdTaskId],
      foreignColumns: [tasks.id],
      name: 'task_suggestions_created_task_id_fkey',
    }),
    // Constraint: confidence must be between 0 and 1
    check(
      'task_suggestions_confidence_range',
      sql`confidence >= 0 AND confidence <= 1`
    ),
    // RLS Policies
    pgPolicy('Admins manage task suggestions', {
      as: 'permissive',
      for: 'all',
      to: ['public'],
      using: sql`is_admin()`,
    }),
  ]
)
```

### 3. Add `suggestionFeedback` table to `/lib/db/schema.ts`

```typescript
export const suggestionFeedback = pgTable(
  'suggestion_feedback',
  {
    id: uuid().defaultRandom().primaryKey().notNull(),
    taskSuggestionId: uuid('task_suggestion_id').notNull(),
    feedbackType: text('feedback_type').notNull(), // 'title_changed', 'description_changed', 'project_changed', 'rejected', etc.
    originalValue: text('original_value'),
    correctedValue: text('corrected_value'),
    createdBy: uuid('created_by').notNull(),
    createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' })
      .default(sql`timezone('utc'::text, now())`)
      .notNull(),
  },
  table => [
    index('idx_suggestion_feedback_suggestion')
      .using('btree', table.taskSuggestionId.asc().nullsLast().op('uuid_ops')),
    foreignKey({
      columns: [table.taskSuggestionId],
      foreignColumns: [taskSuggestions.id],
      name: 'suggestion_feedback_task_suggestion_id_fkey',
    }).onDelete('cascade'),
    foreignKey({
      columns: [table.createdBy],
      foreignColumns: [users.id],
      name: 'suggestion_feedback_created_by_fkey',
    }),
  ]
)
```

### 4. Add relations to `/lib/db/relations.ts`

```typescript
import { taskSuggestions, suggestionFeedback } from './schema'

export const taskSuggestionsRelations = relations(taskSuggestions, ({ one, many }) => ({
  email: one(emailMetadata, {
    fields: [taskSuggestions.emailMetadataId],
    references: [emailMetadata.id],
  }),
  project: one(projects, {
    fields: [taskSuggestions.projectId],
    references: [projects.id],
  }),
  reviewedByUser: one(users, {
    fields: [taskSuggestions.reviewedBy],
    references: [users.id],
  }),
  createdTask: one(tasks, {
    fields: [taskSuggestions.createdTaskId],
    references: [tasks.id],
  }),
  feedback: many(suggestionFeedback),
}))

export const suggestionFeedbackRelations = relations(suggestionFeedback, ({ one }) => ({
  suggestion: one(taskSuggestions, {
    fields: [suggestionFeedback.taskSuggestionId],
    references: [taskSuggestions.id],
  }),
  createdByUser: one(users, {
    fields: [suggestionFeedback.createdBy],
    references: [users.id],
  }),
}))
```

### 5. Create TypeScript types in `/lib/types/suggestions.ts`

```typescript
import type { InferSelectModel, InferInsertModel } from 'drizzle-orm'
import type { taskSuggestions, suggestionFeedback } from '@/lib/db/schema'

export type TaskSuggestion = InferSelectModel<typeof taskSuggestions>
export type NewTaskSuggestion = InferInsertModel<typeof taskSuggestions>

export type SuggestionFeedback = InferSelectModel<typeof suggestionFeedback>
export type NewSuggestionFeedback = InferInsertModel<typeof suggestionFeedback>

export type SuggestionStatus = 'PENDING' | 'APPROVED' | 'REJECTED' | 'MODIFIED' | 'EXPIRED'

export interface TaskSuggestionWithEmail extends TaskSuggestion {
  email: {
    id: string
    subject: string | null
    fromEmail: string
    fromName: string | null
    receivedAt: string
  }
  project?: {
    id: string
    name: string
  } | null
}
```

### 6. Generate and run migration

```bash
npm run db:generate
npm run db:migrate
```

## Schema Design Notes

### taskSuggestions Table
| Column | Purpose |
|--------|---------|
| `emailMetadataId` | Source email |
| `projectId` | Suggested target project |
| `suggestedTitle` | AI-generated task title |
| `suggestedDescription` | AI-generated description |
| `suggestedDueDate` | Extracted deadline if any |
| `suggestedPriority` | HIGH/MEDIUM/LOW |
| `suggestedAssignees` | Suggested user IDs |
| `confidence` | AI confidence score 0-1 |
| `reasoning` | AI's explanation |
| `status` | Review workflow state |
| `reviewedBy` | Who reviewed it |
| `createdTaskId` | Link to created task |
| `aiModelVersion` | Track which model |
| `promptTokens/completionTokens` | Usage tracking |

### suggestionFeedback Table
| Column | Purpose |
|--------|---------|
| `taskSuggestionId` | Which suggestion |
| `feedbackType` | What was changed |
| `originalValue` | AI's original suggestion |
| `correctedValue` | User's correction |
| `createdBy` | Who made correction |

### Feedback Types
- `title_changed` - User modified the title
- `description_changed` - User modified description
- `project_changed` - User selected different project
- `due_date_changed` - User changed due date
- `priority_changed` - User changed priority
- `rejected_not_actionable` - Rejected: not a task
- `rejected_duplicate` - Rejected: already exists
- `rejected_irrelevant` - Rejected: not relevant

## Acceptance Criteria

- [ ] Enum `suggestion_status` created
- [ ] Table `task_suggestions` created with all columns
- [ ] Table `suggestion_feedback` created
- [ ] All indexes for common queries
- [ ] Foreign keys with appropriate cascades
- [ ] Relations added
- [ ] TypeScript types exported
- [ ] Migration generated and applied

## Files Changed
- `lib/db/schema.ts` (modified - add enum and tables)
- `lib/db/relations.ts` (modified - add relations)
- `lib/types/suggestions.ts` (new)
- `drizzle/migrations/` (new migration file)

## Migration Details

**Migration Number:** `0010_task_suggestions.sql`

**Risk Level:** MEDIUM - Creates new tables with FK to existing `tasks` table.

**Note:** The FK to `tasks.id` means this migration depends on the tasks table existing. Since it uses `onDelete: no action` (not cascade), deleting a task won't cascade to suggestions.

## Local Migration Testing Checklist

Before deploying to production, complete this checklist:

```bash
# 1. Generate the migration
npm run db:generate -- --name task_suggestions

# 2. Review generated SQL - especially verify FK definitions
cat drizzle/migrations/0010_task_suggestions.sql

# 3. Apply to LOCAL Supabase database
DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54322/postgres npm run db:migrate
```

### Verification Steps

```sql
-- Verify tables
\d task_suggestions
\d suggestion_feedback

-- Verify enum
SELECT enum_range(NULL::suggestion_status);

-- Verify indexes
\di+ idx_task_suggestions_*
\di+ idx_suggestion_feedback_*

-- Test CHECK constraint: confidence must be 0-1
INSERT INTO task_suggestions (email_metadata_id, suggested_title, confidence, status)
VALUES ('00000000-0000-0000-0000-000000000001', 'Test Task', 1.50, 'PENDING');
-- Expected: check constraint "task_suggestions_confidence_range" violated

-- Test pending index is used
EXPLAIN SELECT * FROM task_suggestions WHERE status = 'PENDING' AND deleted_at IS NULL;
-- Should show index scan on idx_task_suggestions_pending

-- Test FK to tasks table works
INSERT INTO task_suggestions (email_metadata_id, suggested_title, confidence, created_task_id)
VALUES ('00000000-0000-0000-0000-000000000001', 'Test', 0.90, '00000000-0000-0000-0000-000000000999');
-- Expected: FK violation (task doesn't exist)
```

### Rollback Plan

If issues occur:
```sql
DROP TABLE IF EXISTS suggestion_feedback CASCADE;
DROP TABLE IF EXISTS task_suggestions CASCADE;
DROP TYPE IF EXISTS suggestion_status;
```

Then remove the migration file and re-run `db:generate`.

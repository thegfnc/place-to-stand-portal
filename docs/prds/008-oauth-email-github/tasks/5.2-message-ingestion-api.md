# Task 5.2: Message Ingestion API (Create & Route)

## Overview

Create a single server endpoint that accepts inputs from multiple sources (Gmail sync, portal chat composer, web forms, transcripts) and normalizes them into `messages` on a `thread`, creating the thread when needed. This endpoint also triggers optional AI thread title generation when a thread is first created.

## Dependencies

- 5.1 (Threads and Messages Schema)

## Deliverables

1) API route – `app/api/v1/messages/ingest/route.ts` (POST)

Request shape (Zod-validated):

```
{
  idempotencyKey?: string,
  clientId?: string | null,
  threadId?: string,
  source: 'gmail' | 'portal' | 'web_form' | 'transcript',
  type: 'email' | 'chat' | 'voice_memo' | 'document' | 'form' | 'transcript',
  externalId?: string,           // e.g., Gmail message id
  authorKind?: 'internal_user' | 'external_contact' | 'system',
  authorId?: string,
  bodyText?: string,             // normalized text content
  bodyJson?: Record<string,unknown>,
  participants?: {
    from?: string,
    to?: string[],
    cc?: string[]
  },
  metadata?: Record<string,unknown>
}
```

Response shape:

```
{
  thread: { id: string, title: string | null },
  message: { id: string, type: string, createdAt: string }
}
```

2) Routing logic

- If `threadId` provided, attach to that thread.
- Else if `clientId` provided, attempt to find an active thread by recent activity and semantic proximity (later), else create a new thread.
- Else attempt to resolve `clientId` by `participants.from` or `participants.to` via contacts/identity linking (see 5.6). If unresolved, create a new thread with `clientId = null` and placeholder title; surface in Triage UI for manual linking.
- If new thread is created, enqueue background job to generate `title` (see 5.4 AI support note below).
- If `externalId` provided, enforce idempotency: upsert by `(type, externalId)` to avoid duplicates.

3) Idempotency

- Accept `Idempotency-Key` header and/or `idempotencyKey` in body; persist to a short-lived `idempotency_keys` table (TTL) for non-email sources. For email, prefer unique `(type, externalId)`.

4) Authorization & RBAC

- Server-side guards must validate that the current user has access to the `clientId`/`threadId` context using `lib/auth/permissions.ts`.

5) Errors & status codes

- 400 on validation errors; 401/403 for auth/permission failures; 409 on idempotency conflicts; 500 with Sentry capture for unexpected errors.

6) AI thread naming (deferred execution)

- On first message in a thread, enqueue a background task to generate a concise thread `title` from the message(s) using Vercel AI Gateway. Store the result back onto the thread.

## Acceptance Criteria

- Single endpoint ingests email/chat/form/transcript payloads into `messages` with correct linking and idempotency.
- New threads are created when required; existing threads receive new messages without duplication.
- Authorization enforced for portal-originated requests.
- Unit-level Zod validation and typed responses.

## Files Changed

- `app/api/v1/messages/ingest/route.ts` (new)
- `lib/zod/threads.ts` (modified) – request/response schemas
- `lib/auth/permissions.ts` (no functional changes; reused)

## Notes

- Keep the endpoint “dumb but safe”: validate and persist, then offload heavy AI work to workers.
- Ensure logs have request id/user id context with sensitive data redacted.

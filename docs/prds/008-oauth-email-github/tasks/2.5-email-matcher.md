# Task 2.5: Email-to-Client Matcher

## Overview
Create the automatic email matching service that detects when emails are from known client contacts and creates links.

## Dependencies
- Task 2.1 (Client Contacts Schema)
- Task 2.3 (Email Metadata Schema)

## Deliverables

### 1. Create `/lib/email/matcher.ts`

```typescript
import { eq, and, isNull, like } from 'drizzle-orm'
import { db } from '@/lib/db'
import { clientContacts, clients, emailLinks, emailMetadata } from '@/lib/db/schema'
import type { NewEmailLink } from '@/lib/types/emails'

interface MatchResult {
  clientId: string
  clientName: string
  confidence: number
  matchType: 'exact' | 'domain'
  matchedContact?: {
    id: string
    email: string
    name: string | null
  }
}

/**
 * Match an email address to clients
 * Returns all matching clients with confidence scores
 */
export async function matchEmailToClients(
  fromEmail: string
): Promise<MatchResult[]> {
  const email = fromEmail.toLowerCase().trim()
  const domain = email.split('@')[1]

  const matches: MatchResult[] = []

  // 1. Exact email match (confidence: 1.0)
  const exactMatches = await db
    .select({
      clientId: clientContacts.clientId,
      clientName: clients.name,
      contactId: clientContacts.id,
      contactEmail: clientContacts.email,
      contactName: clientContacts.name,
    })
    .from(clientContacts)
    .innerJoin(clients, eq(clients.id, clientContacts.clientId))
    .where(
      and(
        eq(clientContacts.email, email),
        isNull(clientContacts.deletedAt),
        isNull(clients.deletedAt)
      )
    )

  for (const match of exactMatches) {
    matches.push({
      clientId: match.clientId,
      clientName: match.clientName,
      confidence: 1.0,
      matchType: 'exact',
      matchedContact: {
        id: match.contactId,
        email: match.contactEmail,
        name: match.contactName,
      },
    })
  }

  // If we have exact matches, return them (don't add domain matches)
  if (matches.length > 0) {
    return matches
  }

  // 2. Domain match (confidence: 0.7)
  if (domain) {
    const domainMatches = await db
      .select({
        clientId: clientContacts.clientId,
        clientName: clients.name,
      })
      .from(clientContacts)
      .innerJoin(clients, eq(clients.id, clientContacts.clientId))
      .where(
        and(
          like(clientContacts.email, `%@${domain}`),
          isNull(clientContacts.deletedAt),
          isNull(clients.deletedAt)
        )
      )
      .groupBy(clientContacts.clientId, clients.name)

    for (const match of domainMatches) {
      matches.push({
        clientId: match.clientId,
        clientName: match.clientName,
        confidence: 0.7,
        matchType: 'domain',
      })
    }
  }

  return matches
}

/**
 * Process a single email and create automatic links
 */
export async function processEmailForMatching(
  emailId: string
): Promise<{ matched: boolean; links: number }> {
  // Get email metadata
  const [email] = await db
    .select()
    .from(emailMetadata)
    .where(
      and(
        eq(emailMetadata.id, emailId),
        isNull(emailMetadata.deletedAt)
      )
    )
    .limit(1)

  if (!email) {
    return { matched: false, links: 0 }
  }

  // Check if already has automatic links
  const existingLinks = await db
    .select({ id: emailLinks.id })
    .from(emailLinks)
    .where(
      and(
        eq(emailLinks.emailMetadataId, emailId),
        eq(emailLinks.source, 'AUTOMATIC'),
        isNull(emailLinks.deletedAt)
      )
    )
    .limit(1)

  if (existingLinks.length > 0) {
    return { matched: true, links: 0 }
  }

  // Find matches
  const matches = await matchEmailToClients(email.fromEmail)

  if (matches.length === 0) {
    return { matched: false, links: 0 }
  }

  // Create links for all matches
  const newLinks: NewEmailLink[] = matches.map(match => ({
    emailMetadataId: emailId,
    clientId: match.clientId,
    projectId: null,
    source: 'AUTOMATIC' as const,
    confidence: String(match.confidence),
    linkedBy: null,
    notes: match.matchType === 'exact'
      ? `Matched contact: ${match.matchedContact?.email}`
      : `Matched by domain`,
  }))

  await db.insert(emailLinks).values(newLinks)

  return { matched: true, links: newLinks.length }
}

/**
 * Process all unmatched emails for a user
 */
export async function processUnmatchedEmails(
  userId: string
): Promise<{ processed: number; matched: number; links: number }> {
  const unmatchedEmails = await db
    .select({ id: emailMetadata.id })
    .from(emailMetadata)
    .leftJoin(
      emailLinks,
      and(
        eq(emailLinks.emailMetadataId, emailMetadata.id),
        eq(emailLinks.source, 'AUTOMATIC'),
        isNull(emailLinks.deletedAt)
      )
    )
    .where(
      and(
        eq(emailMetadata.userId, userId),
        isNull(emailMetadata.deletedAt),
        isNull(emailLinks.id)
      )
    )
    .limit(500)

  let matched = 0
  let totalLinks = 0

  for (const { id } of unmatchedEmails) {
    const result = await processEmailForMatching(id)
    if (result.matched) matched++
    totalLinks += result.links
  }

  return { processed: unmatchedEmails.length, matched, links: totalLinks }
}

/**
 * Get match suggestions for an email (for UI)
 */
export async function getMatchSuggestions(emailId: string): Promise<{
  email: { id: string; fromEmail: string; subject: string | null }
  suggestions: MatchResult[]
}> {
  const [email] = await db
    .select({
      id: emailMetadata.id,
      fromEmail: emailMetadata.fromEmail,
      subject: emailMetadata.subject,
    })
    .from(emailMetadata)
    .where(eq(emailMetadata.id, emailId))
    .limit(1)

  if (!email) {
    throw new Error('Email not found')
  }

  const suggestions = await matchEmailToClients(email.fromEmail)

  return { email, suggestions }
}
```

### 2. Create `/lib/email/linker.ts`

```typescript
import { eq, and, isNull } from 'drizzle-orm'
import { db } from '@/lib/db'
import { emailLinks } from '@/lib/db/schema'
import type { NewEmailLink, EmailLink } from '@/lib/types/emails'
import { logActivity } from '@/lib/activity/logger'

interface LinkEmailParams {
  emailMetadataId: string
  clientId?: string
  projectId?: string
  source: 'MANUAL_FORWARD' | 'MANUAL_LINK'
  linkedBy: string
  notes?: string
}

/**
 * Manually link an email to a client/project
 */
export async function linkEmail(params: LinkEmailParams): Promise<EmailLink> {
  const { emailMetadataId, clientId, projectId, source, linkedBy, notes } = params

  if (!clientId && !projectId) {
    throw new Error('Must provide clientId or projectId')
  }

  const [link] = await db
    .insert(emailLinks)
    .values({
      emailMetadataId,
      clientId: clientId || null,
      projectId: projectId || null,
      source,
      confidence: null,
      linkedBy,
      notes,
    })
    .returning()

  await logActivity({
    actorId: linkedBy,
    actorRole: 'ADMIN',
    verb: 'EMAIL_LINKED',
    summary: `Linked email to ${clientId ? 'client' : 'project'}`,
    targetType: 'EMAIL',
    targetId: emailMetadataId,
    targetClientId: clientId || undefined,
    targetProjectId: projectId || undefined,
    metadata: { linkId: link.id, source },
  })

  return link
}

/**
 * Remove an email link
 */
export async function unlinkEmail(linkId: string, userId: string): Promise<void> {
  const [link] = await db
    .select()
    .from(emailLinks)
    .where(eq(emailLinks.id, linkId))
    .limit(1)

  if (!link) {
    throw new Error('Link not found')
  }

  await db
    .update(emailLinks)
    .set({
      deletedAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    })
    .where(eq(emailLinks.id, linkId))

  await logActivity({
    actorId: userId,
    actorRole: 'ADMIN',
    verb: 'EMAIL_UNLINKED',
    summary: 'Removed email link',
    targetType: 'EMAIL',
    targetId: link.emailMetadataId,
    targetClientId: link.clientId || undefined,
    targetProjectId: link.projectId || undefined,
    metadata: { linkId },
  })
}
```

### 3. Create `/app/api/emails/[emailId]/link/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'
import { requireRole } from '@/lib/auth/session'
import { linkEmail } from '@/lib/email/linker'
import { getMatchSuggestions, processEmailForMatching } from '@/lib/email/matcher'

const linkSchema = z.object({
  clientId: z.string().uuid().optional(),
  projectId: z.string().uuid().optional(),
  notes: z.string().max(500).optional(),
}).refine(data => data.clientId || data.projectId, {
  message: 'Must provide clientId or projectId',
})

// GET: Get match suggestions
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ emailId: string }> }
) {
  await requireRole('ADMIN')
  const { emailId } = await params

  try {
    const result = await getMatchSuggestions(emailId)
    return NextResponse.json(result)
  } catch (error) {
    return NextResponse.json({ error: 'Failed to get suggestions' }, { status: 500 })
  }
}

// POST: Create manual link
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ emailId: string }> }
) {
  const user = await requireRole('ADMIN')
  const { emailId } = await params

  const body = await request.json()
  const result = linkSchema.safeParse(body)

  if (!result.success) {
    return NextResponse.json({ error: result.error.errors[0].message }, { status: 400 })
  }

  try {
    const link = await linkEmail({
      emailMetadataId: emailId,
      clientId: result.data.clientId,
      projectId: result.data.projectId,
      source: 'MANUAL_LINK',
      linkedBy: user.id,
      notes: result.data.notes,
    })

    return NextResponse.json({ success: true, link })
  } catch (error) {
    return NextResponse.json({ error: 'Failed to create link' }, { status: 500 })
  }
}
```

### 4. Create `/app/api/emails/links/[linkId]/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { requireRole } from '@/lib/auth/session'
import { unlinkEmail } from '@/lib/email/linker'

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ linkId: string }> }
) {
  const user = await requireRole('ADMIN')
  const { linkId } = await params

  try {
    await unlinkEmail(linkId, user.id)
    return NextResponse.json({ success: true })
  } catch (error) {
    return NextResponse.json({ error: 'Failed to remove link' }, { status: 500 })
  }
}
```

### 5. Add activity verbs to `/lib/activity/logger.ts`

```typescript
'EMAIL_LINKED'
'EMAIL_UNLINKED'
'EMAIL_SYNCED'
```

### 6. Update sync to run matching

Add to end of `syncGmailForUser` in `/lib/email/sync.ts`:

```typescript
// After syncing, run automatic matching
if (result.synced > 0) {
  await processUnmatchedEmails(userId)
}
```

## Acceptance Criteria

- [ ] Exact email match returns confidence 1.0
- [ ] Domain match returns confidence 0.7
- [ ] Automatic links created during sync
- [ ] Manual link/unlink works via API
- [ ] Activity logged for all operations
- [ ] No duplicate automatic links created
- [ ] Match suggestions endpoint works

## Files Changed
- `lib/email/matcher.ts` (new)
- `lib/email/linker.ts` (new)
- `lib/email/sync.ts` (modified)
- `app/api/emails/[emailId]/link/route.ts` (new)
- `app/api/emails/links/[linkId]/route.ts` (new)
- `lib/activity/logger.ts` (modified)

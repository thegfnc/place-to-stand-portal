# Task 2.4: Email Sync Service

## Overview
Create a service that syncs Gmail messages to the database, storing metadata for later linking and analysis.

## Dependencies
- Task 1.4 (Gmail Client)
- Task 2.3 (Email Metadata Schema)

## Deliverables

### 1. Create `/lib/email/sync.ts`

```typescript
import { eq, and, isNull, desc, inArray } from 'drizzle-orm'
import { db } from '@/lib/db'
import { emailMetadata, oauthConnections } from '@/lib/db/schema'
import { listMessages, getMessages, parseMessage, updateLastSyncTime } from '@/lib/gmail/client'
import type { ParsedEmail } from '@/lib/gmail/types'
import type { NewEmailMetadata } from '@/lib/types/emails'

const SYNC_BATCH_SIZE = 50
const MAX_MESSAGES_PER_SYNC = 200

interface SyncResult {
  synced: number
  skipped: number
  errors: number
}

/**
 * Convert parsed Gmail message to database format
 */
function toEmailMetadata(userId: string, email: ParsedEmail): NewEmailMetadata {
  return {
    userId,
    gmailMessageId: email.id,
    gmailThreadId: email.threadId,
    subject: email.subject || null,
    snippet: email.snippet || null,
    fromEmail: email.from.email.toLowerCase(),
    fromName: email.from.name || null,
    toEmails: email.to.map(t => t.email.toLowerCase()),
    ccEmails: email.cc.map(c => c.email.toLowerCase()),
    receivedAt: email.date.toISOString(),
    isRead: !email.labels.includes('UNREAD'),
    hasAttachments: email.hasAttachments,
    labels: email.labels,
    rawMetadata: {},
  }
}

/**
 * Get list of Gmail message IDs already synced for a user
 */
async function getExistingMessageIds(
  userId: string,
  gmailIds: string[]
): Promise<Set<string>> {
  if (gmailIds.length === 0) return new Set()

  const existing = await db
    .select({ gmailMessageId: emailMetadata.gmailMessageId })
    .from(emailMetadata)
    .where(
      and(
        eq(emailMetadata.userId, userId),
        inArray(emailMetadata.gmailMessageId, gmailIds),
        isNull(emailMetadata.deletedAt)
      )
    )

  return new Set(existing.map(e => e.gmailMessageId))
}

/**
 * Sync Gmail messages for a single user
 */
export async function syncGmailForUser(userId: string): Promise<SyncResult> {
  const result: SyncResult = { synced: 0, skipped: 0, errors: 0 }

  try {
    // Get recent messages from Gmail
    const listResponse = await listMessages(userId, {
      maxResults: MAX_MESSAGES_PER_SYNC,
      labelIds: ['INBOX'], // Only sync inbox for now
    })

    if (!listResponse.messages || listResponse.messages.length === 0) {
      await updateLastSyncTime(userId)
      return result
    }

    const gmailIds = listResponse.messages.map(m => m.id)

    // Check which are already synced
    const existingIds = await getExistingMessageIds(userId, gmailIds)

    // Filter to only new messages
    const newMessageIds = gmailIds.filter(id => !existingIds.has(id))
    result.skipped = existingIds.size

    if (newMessageIds.length === 0) {
      await updateLastSyncTime(userId)
      return result
    }

    // Fetch and sync in batches
    for (let i = 0; i < newMessageIds.length; i += SYNC_BATCH_SIZE) {
      const batch = newMessageIds.slice(i, i + SYNC_BATCH_SIZE)

      try {
        const messages = await getMessages(userId, batch, 'metadata')
        const parsed = messages.map(parseMessage)
        const records = parsed.map(p => toEmailMetadata(userId, p))

        // Insert batch
        await db
          .insert(emailMetadata)
          .values(records)
          .onConflictDoNothing() // Skip if already exists

        result.synced += records.length
      } catch (error) {
        console.error(`Sync batch error for user ${userId}:`, error)
        result.errors += batch.length
      }
    }

    await updateLastSyncTime(userId)
    return result
  } catch (error) {
    console.error(`Sync error for user ${userId}:`, error)
    throw error
  }
}

/**
 * Sync Gmail for all users with active Google connections
 */
export async function syncGmailForAllUsers(): Promise<{
  processed: number
  results: Array<{ userId: string; result: SyncResult | { error: string } }>
}> {
  // Get all active Google connections
  const connections = await db
    .select({ userId: oauthConnections.userId })
    .from(oauthConnections)
    .where(
      and(
        eq(oauthConnections.provider, 'GOOGLE'),
        eq(oauthConnections.status, 'ACTIVE'),
        isNull(oauthConnections.deletedAt)
      )
    )

  const results: Array<{ userId: string; result: SyncResult | { error: string } }> = []

  for (const { userId } of connections) {
    try {
      const result = await syncGmailForUser(userId)
      results.push({ userId, result })
    } catch (error) {
      results.push({
        userId,
        result: { error: error instanceof Error ? error.message : 'Unknown error' },
      })
    }
  }

  return { processed: connections.length, results }
}

/**
 * Get sync status for a user
 */
export async function getEmailSyncStatus(userId: string): Promise<{
  totalEmails: number
  lastSyncAt: string | null
  oldestEmail: string | null
  newestEmail: string | null
}> {
  const [connection] = await db
    .select({ lastSyncAt: oauthConnections.lastSyncAt })
    .from(oauthConnections)
    .where(
      and(
        eq(oauthConnections.userId, userId),
        eq(oauthConnections.provider, 'GOOGLE'),
        isNull(oauthConnections.deletedAt)
      )
    )
    .limit(1)

  const [stats] = await db
    .select({
      count: sql<number>`count(*)::int`,
      oldest: sql<string>`min(received_at)`,
      newest: sql<string>`max(received_at)`,
    })
    .from(emailMetadata)
    .where(
      and(
        eq(emailMetadata.userId, userId),
        isNull(emailMetadata.deletedAt)
      )
    )

  return {
    totalEmails: stats?.count ?? 0,
    lastSyncAt: connection?.lastSyncAt ?? null,
    oldestEmail: stats?.oldest ?? null,
    newestEmail: stats?.newest ?? null,
  }
}
```

### 2. Create `/app/api/cron/gmail-sync/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { syncGmailForAllUsers } from '@/lib/email/sync'

export const runtime = 'nodejs'
export const maxDuration = 60 // 60 seconds max

export async function GET(request: NextRequest) {
  // Verify cron secret (Vercel adds authorization header)
  const authHeader = request.headers.get('authorization')
  const cronSecret = process.env.CRON_SECRET

  if (cronSecret && authHeader !== `Bearer ${cronSecret}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  try {
    const result = await syncGmailForAllUsers()

    console.log(`Gmail sync completed: ${result.processed} users processed`)

    return NextResponse.json({
      success: true,
      processed: result.processed,
      results: result.results,
    })
  } catch (error) {
    console.error('Gmail sync cron error:', error)
    return NextResponse.json(
      { error: 'Sync failed', message: error instanceof Error ? error.message : 'Unknown' },
      { status: 500 }
    )
  }
}
```

### 3. Create manual sync endpoint `/app/api/integrations/gmail/sync/route.ts`

```typescript
import { NextResponse } from 'next/server'
import { requireUser } from '@/lib/auth/session'
import { syncGmailForUser, getEmailSyncStatus } from '@/lib/email/sync'

export async function POST() {
  const user = await requireUser()

  try {
    const result = await syncGmailForUser(user.id)

    return NextResponse.json({
      success: true,
      synced: result.synced,
      skipped: result.skipped,
      errors: result.errors,
    })
  } catch (error) {
    console.error('Manual Gmail sync error:', error)

    if (error instanceof Error && error.message.includes('reconnection required')) {
      return NextResponse.json(
        { error: 'Google reconnection required', code: 'REAUTH_REQUIRED' },
        { status: 401 }
      )
    }

    return NextResponse.json(
      { error: 'Sync failed' },
      { status: 500 }
    )
  }
}

export async function GET() {
  const user = await requireUser()

  try {
    const status = await getEmailSyncStatus(user.id)
    return NextResponse.json(status)
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to get sync status' },
      { status: 500 }
    )
  }
}
```

### 4. Add cron configuration to `vercel.json`

```json
{
  "crons": [
    {
      "path": "/api/cron/gmail-sync",
      "schedule": "*/5 * * * *"
    }
  ]
}
```

### 5. Add environment variable

Add to `.env.example`:
```bash
# Cron job authentication (generate with: openssl rand -hex 32)
CRON_SECRET=
```

### 6. Create `/lib/data/emails/index.ts`

```typescript
import { eq, and, isNull, desc, sql } from 'drizzle-orm'
import { db } from '@/lib/db'
import { emailMetadata, emailLinks, clients, projects } from '@/lib/db/schema'
import type { EmailWithLinks } from '@/lib/types/emails'

export async function getEmailsForUser(
  userId: string,
  options: {
    limit?: number
    offset?: number
    linkedOnly?: boolean
  } = {}
): Promise<EmailWithLinks[]> {
  const { limit = 50, offset = 0, linkedOnly = false } = options

  let query = db
    .select()
    .from(emailMetadata)
    .where(
      and(
        eq(emailMetadata.userId, userId),
        isNull(emailMetadata.deletedAt)
      )
    )
    .orderBy(desc(emailMetadata.receivedAt))
    .limit(limit)
    .offset(offset)

  const emails = await query

  // Fetch links for each email
  const emailIds = emails.map(e => e.id)

  const links = emailIds.length > 0
    ? await db
        .select({
          emailMetadataId: emailLinks.emailMetadataId,
          id: emailLinks.id,
          source: emailLinks.source,
          confidence: emailLinks.confidence,
          clientId: emailLinks.clientId,
          clientName: clients.name,
          projectId: emailLinks.projectId,
          projectName: projects.name,
        })
        .from(emailLinks)
        .leftJoin(clients, eq(clients.id, emailLinks.clientId))
        .leftJoin(projects, eq(projects.id, emailLinks.projectId))
        .where(
          and(
            sql`${emailLinks.emailMetadataId} IN (${sql.join(emailIds.map(id => sql`${id}`), sql`, `)})`,
            isNull(emailLinks.deletedAt)
          )
        )
    : []

  // Group links by email
  const linksByEmail = new Map<string, typeof links>()
  for (const link of links) {
    const existing = linksByEmail.get(link.emailMetadataId) || []
    existing.push(link)
    linksByEmail.set(link.emailMetadataId, existing)
  }

  // Build result
  const result: EmailWithLinks[] = emails.map(email => ({
    ...email,
    links: (linksByEmail.get(email.id) || []).map(l => ({
      id: l.id,
      source: l.source as EmailWithLinks['links'][0]['source'],
      confidence: l.confidence,
      client: l.clientId ? { id: l.clientId, name: l.clientName! } : null,
      project: l.projectId ? { id: l.projectId, name: l.projectName! } : null,
    })),
  }))

  if (linkedOnly) {
    return result.filter(e => e.links.length > 0)
  }

  return result
}

export async function getEmailById(
  userId: string,
  emailId: string
): Promise<EmailWithLinks | null> {
  const [email] = await db
    .select()
    .from(emailMetadata)
    .where(
      and(
        eq(emailMetadata.id, emailId),
        eq(emailMetadata.userId, userId),
        isNull(emailMetadata.deletedAt)
      )
    )
    .limit(1)

  if (!email) return null

  const links = await db
    .select({
      id: emailLinks.id,
      source: emailLinks.source,
      confidence: emailLinks.confidence,
      clientId: emailLinks.clientId,
      clientName: clients.name,
      projectId: emailLinks.projectId,
      projectName: projects.name,
    })
    .from(emailLinks)
    .leftJoin(clients, eq(clients.id, emailLinks.clientId))
    .leftJoin(projects, eq(projects.id, emailLinks.projectId))
    .where(
      and(
        eq(emailLinks.emailMetadataId, emailId),
        isNull(emailLinks.deletedAt)
      )
    )

  return {
    ...email,
    links: links.map(l => ({
      id: l.id,
      source: l.source as EmailWithLinks['links'][0]['source'],
      confidence: l.confidence,
      client: l.clientId ? { id: l.clientId, name: l.clientName! } : null,
      project: l.projectId ? { id: l.projectId, name: l.projectName! } : null,
    })),
  }
}
```

## Acceptance Criteria

- [ ] Sync service fetches new Gmail messages
- [ ] Existing messages are skipped (deduplication)
- [ ] Email metadata stored in database
- [ ] Last sync timestamp updated
- [ ] Cron endpoint for automated sync
- [ ] Manual sync endpoint for on-demand sync
- [ ] Sync status endpoint returns stats
- [ ] Error handling for token expiration
- [ ] Batch processing for large sync operations
- [ ] Data access functions for reading emails

## Files Changed
- `lib/email/sync.ts` (new)
- `lib/data/emails/index.ts` (new)
- `app/api/cron/gmail-sync/route.ts` (new)
- `app/api/integrations/gmail/sync/route.ts` (new)
- `vercel.json` (modified - add cron)
- `.env.example` (modified - add CRON_SECRET)

## Testing

1. Connect Google account
2. Trigger manual sync: `POST /api/integrations/gmail/sync`
3. Check sync status: `GET /api/integrations/gmail/sync`
4. Verify emails in database
5. Re-run sync - should skip existing emails

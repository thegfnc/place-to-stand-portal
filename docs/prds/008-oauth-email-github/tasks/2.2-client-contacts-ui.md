# Task 2.2: Client Contacts UI

## Overview
Add UI for managing client contacts (email addresses) on the client detail page. Users can add, edit, and remove contact emails.

## Dependencies
- Task 2.1 (Client Contacts Schema)

## Design System Reference

Use existing patterns:
- Sheet component for add/edit forms
- Table for listing contacts
- Form with React Hook Form + Zod
- Toast for notifications
- ConfirmDialog for delete confirmation

## Deliverables

### 1. Create `/lib/data/client-contacts/index.ts`

```typescript
import { eq, and, isNull, desc } from 'drizzle-orm'
import { db } from '@/lib/db'
import { clientContacts, clients } from '@/lib/db/schema'
import type { ClientContact } from '@/lib/types/client-contacts'

export async function getClientContacts(clientId: string): Promise<ClientContact[]> {
  return db
    .select()
    .from(clientContacts)
    .where(
      and(
        eq(clientContacts.clientId, clientId),
        isNull(clientContacts.deletedAt)
      )
    )
    .orderBy(desc(clientContacts.isPrimary), clientContacts.email)
}

export async function getClientContactById(
  contactId: string
): Promise<ClientContact | null> {
  const [contact] = await db
    .select()
    .from(clientContacts)
    .where(
      and(
        eq(clientContacts.id, contactId),
        isNull(clientContacts.deletedAt)
      )
    )
    .limit(1)

  return contact ?? null
}

export async function createClientContact(data: {
  clientId: string
  email: string
  name?: string
  isPrimary?: boolean
  createdBy: string
}): Promise<ClientContact> {
  const [contact] = await db
    .insert(clientContacts)
    .values({
      clientId: data.clientId,
      email: data.email.toLowerCase().trim(),
      name: data.name?.trim() || null,
      isPrimary: data.isPrimary ?? false,
      createdBy: data.createdBy,
    })
    .returning()

  return contact
}

export async function updateClientContact(
  contactId: string,
  data: {
    email?: string
    name?: string
    isPrimary?: boolean
  }
): Promise<ClientContact> {
  const updateData: Partial<ClientContact> = {
    updatedAt: new Date().toISOString(),
  }

  if (data.email !== undefined) {
    updateData.email = data.email.toLowerCase().trim()
  }
  if (data.name !== undefined) {
    updateData.name = data.name.trim() || null
  }
  if (data.isPrimary !== undefined) {
    updateData.isPrimary = data.isPrimary
  }

  const [contact] = await db
    .update(clientContacts)
    .set(updateData)
    .where(eq(clientContacts.id, contactId))
    .returning()

  return contact
}

export async function deleteClientContact(contactId: string): Promise<void> {
  await db
    .update(clientContacts)
    .set({
      deletedAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    })
    .where(eq(clientContacts.id, contactId))
}
```

### 2. Create `/lib/settings/client-contacts/schema.ts`

```typescript
import { z } from 'zod'

export const clientContactSchema = z.object({
  email: z
    .string()
    .min(1, 'Email is required')
    .email('Invalid email address')
    .transform(v => v.toLowerCase().trim()),
  name: z
    .string()
    .max(100, 'Name too long')
    .optional()
    .transform(v => v?.trim() || undefined),
  isPrimary: z.boolean().default(false),
})

export type ClientContactFormValues = z.infer<typeof clientContactSchema>
```

### 3. Create `/app/(dashboard)/clients/[clientId]/contacts/actions.ts`

```typescript
'use server'

import { revalidatePath } from 'next/cache'
import { requireRole } from '@/lib/auth/session'
import {
  createClientContact,
  updateClientContact,
  deleteClientContact,
  getClientContactById,
} from '@/lib/data/client-contacts'
import { logActivity } from '@/lib/activity/logger'
import { clientContactSchema } from '@/lib/settings/client-contacts/schema'

export async function addClientContactAction(
  clientId: string,
  formData: FormData
) {
  const user = await requireRole('ADMIN')

  const rawData = {
    email: formData.get('email'),
    name: formData.get('name'),
    isPrimary: formData.get('isPrimary') === 'true',
  }

  const result = clientContactSchema.safeParse(rawData)
  if (!result.success) {
    return { success: false, error: result.error.errors[0].message }
  }

  try {
    const contact = await createClientContact({
      clientId,
      ...result.data,
      createdBy: user.id,
    })

    await logActivity({
      actorId: user.id,
      actorRole: user.role,
      verb: 'CLIENT_CONTACT_CREATED',
      summary: `Added contact ${contact.email} to client`,
      targetType: 'CLIENT',
      targetId: clientId,
      targetClientId: clientId,
      metadata: { contactId: contact.id, email: contact.email },
    })

    revalidatePath(`/clients/${clientId}`)
    return { success: true, contact }
  } catch (error) {
    if (error instanceof Error && error.message.includes('unique')) {
      return { success: false, error: 'This email is already added to this client' }
    }
    return { success: false, error: 'Failed to add contact' }
  }
}

export async function updateClientContactAction(
  contactId: string,
  formData: FormData
) {
  const user = await requireRole('ADMIN')

  const contact = await getClientContactById(contactId)
  if (!contact) {
    return { success: false, error: 'Contact not found' }
  }

  const rawData = {
    email: formData.get('email'),
    name: formData.get('name'),
    isPrimary: formData.get('isPrimary') === 'true',
  }

  const result = clientContactSchema.safeParse(rawData)
  if (!result.success) {
    return { success: false, error: result.error.errors[0].message }
  }

  try {
    const updated = await updateClientContact(contactId, result.data)

    await logActivity({
      actorId: user.id,
      actorRole: user.role,
      verb: 'CLIENT_CONTACT_UPDATED',
      summary: `Updated contact ${updated.email}`,
      targetType: 'CLIENT',
      targetId: contact.clientId,
      targetClientId: contact.clientId,
      metadata: { contactId: updated.id },
    })

    revalidatePath(`/clients/${contact.clientId}`)
    return { success: true, contact: updated }
  } catch (error) {
    if (error instanceof Error && error.message.includes('unique')) {
      return { success: false, error: 'This email is already added to this client' }
    }
    return { success: false, error: 'Failed to update contact' }
  }
}

export async function deleteClientContactAction(contactId: string) {
  const user = await requireRole('ADMIN')

  const contact = await getClientContactById(contactId)
  if (!contact) {
    return { success: false, error: 'Contact not found' }
  }

  await deleteClientContact(contactId)

  await logActivity({
    actorId: user.id,
    actorRole: user.role,
    verb: 'CLIENT_CONTACT_DELETED',
    summary: `Removed contact ${contact.email}`,
    targetType: 'CLIENT',
    targetId: contact.clientId,
    targetClientId: contact.clientId,
    metadata: { contactId, email: contact.email },
  })

  revalidatePath(`/clients/${contact.clientId}`)
  return { success: true }
}
```

### 4. Create `/app/(dashboard)/clients/[clientId]/_components/client-contacts-section.tsx`

```typescript
'use client'

import { useState } from 'react'
import { Plus, Pencil, Trash2, Star, Mail } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table'
import { ConfirmDialog } from '@/components/ui/confirm-dialog'
import { useToast } from '@/components/ui/use-toast'
import type { ClientContact } from '@/lib/types/client-contacts'
import { deleteClientContactAction } from '../contacts/actions'
import { ClientContactSheet } from './client-contact-sheet'

interface ClientContactsSectionProps {
  clientId: string
  contacts: ClientContact[]
}

export function ClientContactsSection({
  clientId,
  contacts,
}: ClientContactsSectionProps) {
  const { toast } = useToast()
  const [sheetOpen, setSheetOpen] = useState(false)
  const [editingContact, setEditingContact] = useState<ClientContact | null>(null)
  const [deleteConfirm, setDeleteConfirm] = useState<ClientContact | null>(null)
  const [isDeleting, setIsDeleting] = useState(false)

  const handleEdit = (contact: ClientContact) => {
    setEditingContact(contact)
    setSheetOpen(true)
  }

  const handleAdd = () => {
    setEditingContact(null)
    setSheetOpen(true)
  }

  const handleDelete = async () => {
    if (!deleteConfirm) return

    setIsDeleting(true)
    try {
      const result = await deleteClientContactAction(deleteConfirm.id)
      if (result.success) {
        toast({
          title: 'Contact removed',
          description: `${deleteConfirm.email} has been removed.`,
        })
      } else {
        toast({
          title: 'Error',
          description: result.error,
          variant: 'destructive',
        })
      }
    } finally {
      setIsDeleting(false)
      setDeleteConfirm(null)
    }
  }

  return (
    <div className='space-y-4'>
      <div className='flex items-center justify-between'>
        <div>
          <h3 className='text-lg font-medium'>Contacts</h3>
          <p className='text-sm text-muted-foreground'>
            Email addresses associated with this client for automatic email matching.
          </p>
        </div>
        <Button onClick={handleAdd} size='sm'>
          <Plus className='mr-2 h-4 w-4' />
          Add Contact
        </Button>
      </div>

      {contacts.length === 0 ? (
        <div className='rounded-lg border border-dashed p-8 text-center'>
          <Mail className='mx-auto h-8 w-8 text-muted-foreground' />
          <p className='mt-2 text-sm text-muted-foreground'>
            No contacts added yet. Add email addresses to enable automatic email linking.
          </p>
          <Button onClick={handleAdd} variant='outline' size='sm' className='mt-4'>
            <Plus className='mr-2 h-4 w-4' />
            Add First Contact
          </Button>
        </div>
      ) : (
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Email</TableHead>
              <TableHead>Name</TableHead>
              <TableHead className='w-24'>Primary</TableHead>
              <TableHead className='w-24'>Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {contacts.map(contact => (
              <TableRow key={contact.id}>
                <TableCell className='font-medium'>{contact.email}</TableCell>
                <TableCell>{contact.name || 'â€”'}</TableCell>
                <TableCell>
                  {contact.isPrimary && (
                    <Badge variant='outline'>
                      <Star className='mr-1 h-3 w-3 fill-current' />
                      Primary
                    </Badge>
                  )}
                </TableCell>
                <TableCell>
                  <div className='flex gap-1'>
                    <Button
                      variant='ghost'
                      size='icon-sm'
                      onClick={() => handleEdit(contact)}
                    >
                      <Pencil className='h-4 w-4' />
                    </Button>
                    <Button
                      variant='ghost'
                      size='icon-sm'
                      onClick={() => setDeleteConfirm(contact)}
                    >
                      <Trash2 className='h-4 w-4' />
                    </Button>
                  </div>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      )}

      <ClientContactSheet
        open={sheetOpen}
        onOpenChange={setSheetOpen}
        clientId={clientId}
        contact={editingContact}
      />

      <ConfirmDialog
        open={!!deleteConfirm}
        title='Remove contact?'
        description={`Are you sure you want to remove ${deleteConfirm?.email}? Emails from this address will no longer be automatically linked to this client.`}
        confirmLabel='Remove'
        cancelLabel='Cancel'
        confirmVariant='destructive'
        isLoading={isDeleting}
        onConfirm={handleDelete}
        onCancel={() => setDeleteConfirm(null)}
      />
    </div>
  )
}
```

### 5. Create `/app/(dashboard)/clients/[clientId]/_components/client-contact-sheet.tsx`

```typescript
'use client'

import { useEffect } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { Loader2 } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Checkbox } from '@/components/ui/checkbox'
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetDescription,
} from '@/components/ui/sheet'
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  FormDescription,
} from '@/components/ui/form'
import { useToast } from '@/components/ui/use-toast'
import type { ClientContact } from '@/lib/types/client-contacts'
import {
  clientContactSchema,
  type ClientContactFormValues,
} from '@/lib/settings/client-contacts/schema'
import {
  addClientContactAction,
  updateClientContactAction,
} from '../contacts/actions'

interface ClientContactSheetProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  clientId: string
  contact: ClientContact | null
}

export function ClientContactSheet({
  open,
  onOpenChange,
  clientId,
  contact,
}: ClientContactSheetProps) {
  const { toast } = useToast()
  const isEditing = !!contact

  const form = useForm<ClientContactFormValues>({
    resolver: zodResolver(clientContactSchema),
    defaultValues: {
      email: '',
      name: '',
      isPrimary: false,
    },
  })

  useEffect(() => {
    if (open) {
      if (contact) {
        form.reset({
          email: contact.email,
          name: contact.name || '',
          isPrimary: contact.isPrimary,
        })
      } else {
        form.reset({
          email: '',
          name: '',
          isPrimary: false,
        })
      }
    }
  }, [open, contact, form])

  const onSubmit = async (values: ClientContactFormValues) => {
    const formData = new FormData()
    formData.set('email', values.email)
    formData.set('name', values.name || '')
    formData.set('isPrimary', String(values.isPrimary))

    const result = isEditing
      ? await updateClientContactAction(contact.id, formData)
      : await addClientContactAction(clientId, formData)

    if (result.success) {
      toast({
        title: isEditing ? 'Contact updated' : 'Contact added',
        description: `${values.email} has been ${isEditing ? 'updated' : 'added'}.`,
      })
      onOpenChange(false)
    } else {
      toast({
        title: 'Error',
        description: result.error,
        variant: 'destructive',
      })
    }
  }

  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      <SheetContent>
        <SheetHeader>
          <SheetTitle>{isEditing ? 'Edit Contact' : 'Add Contact'}</SheetTitle>
          <SheetDescription>
            {isEditing
              ? 'Update the contact details.'
              : 'Add an email address to link incoming emails to this client.'}
          </SheetDescription>
        </SheetHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className='mt-6 space-y-4'>
            <FormField
              control={form.control}
              name='email'
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Email</FormLabel>
                  <FormControl>
                    <Input
                      {...field}
                      type='email'
                      placeholder='contact@example.com'
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name='name'
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Name (optional)</FormLabel>
                  <FormControl>
                    <Input {...field} placeholder='John Smith' />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name='isPrimary'
              render={({ field }) => (
                <FormItem className='flex flex-row items-start space-x-3 space-y-0'>
                  <FormControl>
                    <Checkbox
                      checked={field.value}
                      onCheckedChange={field.onChange}
                    />
                  </FormControl>
                  <div className='space-y-1 leading-none'>
                    <FormLabel>Primary contact</FormLabel>
                    <FormDescription>
                      Mark this as the main contact for this client.
                    </FormDescription>
                  </div>
                </FormItem>
              )}
            />

            <div className='flex justify-end gap-2 pt-4'>
              <Button
                type='button'
                variant='outline'
                onClick={() => onOpenChange(false)}
              >
                Cancel
              </Button>
              <Button type='submit' disabled={form.formState.isSubmitting}>
                {form.formState.isSubmitting ? (
                  <>
                    <Loader2 className='mr-2 h-4 w-4 animate-spin' />
                    {isEditing ? 'Updating...' : 'Adding...'}
                  </>
                ) : isEditing ? (
                  'Update Contact'
                ) : (
                  'Add Contact'
                )}
              </Button>
            </div>
          </form>
        </Form>
      </SheetContent>
    </Sheet>
  )
}
```

### 6. Add activity verbs to `/lib/activity/logger.ts`

Add these verbs:
```typescript
'CLIENT_CONTACT_CREATED'
'CLIENT_CONTACT_UPDATED'
'CLIENT_CONTACT_DELETED'
```

### 7. Integrate into client detail page

Add to the existing client detail page (wherever client info is shown):

```typescript
import { getClientContacts } from '@/lib/data/client-contacts'
import { ClientContactsSection } from './_components/client-contacts-section'

// In the page component:
const contacts = await getClientContacts(clientId)

// In the JSX:
<ClientContactsSection clientId={clientId} contacts={contacts} />
```

## Acceptance Criteria

- [ ] Contacts table shows on client detail page
- [ ] Can add new contact with email and optional name
- [ ] Can mark contact as primary
- [ ] Can edit existing contact
- [ ] Can delete contact with confirmation
- [ ] Duplicate email shows error
- [ ] Empty state shows helpful message
- [ ] Toast notifications for all actions
- [ ] Activity logged for all changes
- [ ] Form validation works correctly

## Files Changed
- `lib/data/client-contacts/index.ts` (new)
- `lib/settings/client-contacts/schema.ts` (new)
- `app/(dashboard)/clients/[clientId]/contacts/actions.ts` (new)
- `app/(dashboard)/clients/[clientId]/_components/client-contacts-section.tsx` (new)
- `app/(dashboard)/clients/[clientId]/_components/client-contact-sheet.tsx` (new)
- `lib/activity/logger.ts` (modified - add verbs)
- Client detail page (modified - add section)

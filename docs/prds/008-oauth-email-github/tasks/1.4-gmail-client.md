# Task 1.4: Gmail API Client

## Overview
Create a Gmail API client with automatic token refresh, basic message listing, and message fetching capabilities.

## Dependencies
- Task 1.3 (Google OAuth Flow)

## Deliverables

### 1. Create `/lib/gmail/types.ts`

```typescript
export interface GmailMessage {
  id: string
  threadId: string
  labelIds: string[]
  snippet: string
  historyId: string
  internalDate: string // Unix timestamp in ms
  payload: GmailMessagePayload
  sizeEstimate: number
}

export interface GmailMessagePayload {
  partId?: string
  mimeType: string
  filename?: string
  headers: GmailHeader[]
  body: GmailBody
  parts?: GmailMessagePayload[]
}

export interface GmailHeader {
  name: string
  value: string
}

export interface GmailBody {
  attachmentId?: string
  size: number
  data?: string // Base64 encoded
}

export interface GmailListResponse {
  messages?: Array<{ id: string; threadId: string }>
  nextPageToken?: string
  resultSizeEstimate: number
}

export interface GmailLabel {
  id: string
  name: string
  type: 'system' | 'user'
  messagesTotal?: number
  messagesUnread?: number
}

export interface ParsedEmail {
  id: string
  threadId: string
  subject: string
  snippet: string
  from: { email: string; name?: string }
  to: Array<{ email: string; name?: string }>
  cc: Array<{ email: string; name?: string }>
  date: Date
  labels: string[]
  hasAttachments: boolean
  body?: {
    plain?: string
    html?: string
  }
}
```

### 2. Create `/lib/gmail/client.ts`

```typescript
import { eq, and, isNull } from 'drizzle-orm'
import { db } from '@/lib/db'
import { oauthConnections } from '@/lib/db/schema'
import { decryptToken, encryptToken } from '@/lib/oauth/encryption'
import { refreshAccessToken } from '@/lib/oauth/google'
import type {
  GmailMessage,
  GmailListResponse,
  GmailLabel,
  ParsedEmail,
} from './types'

const GMAIL_API_BASE = 'https://gmail.googleapis.com/gmail/v1/users/me'

/**
 * Get a valid access token for a user, refreshing if needed
 */
async function getValidAccessToken(userId: string): Promise<string> {
  const [connection] = await db
    .select()
    .from(oauthConnections)
    .where(
      and(
        eq(oauthConnections.userId, userId),
        eq(oauthConnections.provider, 'GOOGLE'),
        eq(oauthConnections.status, 'ACTIVE'),
        isNull(oauthConnections.deletedAt)
      )
    )
    .limit(1)

  if (!connection) {
    throw new Error('No active Google connection found')
  }

  const accessToken = decryptToken(connection.accessToken)
  const expiresAt = connection.accessTokenExpiresAt
    ? new Date(connection.accessTokenExpiresAt)
    : null

  // If token expires in less than 5 minutes, refresh it
  const shouldRefresh = expiresAt && expiresAt.getTime() - Date.now() < 5 * 60 * 1000

  if (shouldRefresh && connection.refreshToken) {
    try {
      const refreshToken = decryptToken(connection.refreshToken)
      const newTokens = await refreshAccessToken(refreshToken)

      const newExpiresAt = new Date(Date.now() + newTokens.expires_in * 1000)

      await db
        .update(oauthConnections)
        .set({
          accessToken: encryptToken(newTokens.access_token),
          accessTokenExpiresAt: newExpiresAt.toISOString(),
          updatedAt: new Date().toISOString(),
        })
        .where(eq(oauthConnections.id, connection.id))

      return newTokens.access_token
    } catch (error) {
      // Mark as needing reauth
      await db
        .update(oauthConnections)
        .set({
          status: 'PENDING_REAUTH',
          updatedAt: new Date().toISOString(),
        })
        .where(eq(oauthConnections.id, connection.id))

      throw new Error('Token refresh failed, reconnection required')
    }
  }

  return accessToken
}

/**
 * Make authenticated request to Gmail API
 */
async function gmailFetch<T>(
  userId: string,
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const accessToken = await getValidAccessToken(userId)

  const response = await fetch(`${GMAIL_API_BASE}${endpoint}`, {
    ...options,
    headers: {
      Authorization: `Bearer ${accessToken}`,
      'Content-Type': 'application/json',
      ...options.headers,
    },
  })

  if (!response.ok) {
    const error = await response.text()
    throw new Error(`Gmail API error (${response.status}): ${error}`)
  }

  return response.json()
}

/**
 * List messages from inbox
 */
export async function listMessages(
  userId: string,
  options: {
    maxResults?: number
    pageToken?: string
    query?: string // Gmail search query
    labelIds?: string[]
  } = {}
): Promise<GmailListResponse> {
  const params = new URLSearchParams()

  if (options.maxResults) params.set('maxResults', String(options.maxResults))
  if (options.pageToken) params.set('pageToken', options.pageToken)
  if (options.query) params.set('q', options.query)
  if (options.labelIds) {
    options.labelIds.forEach(id => params.append('labelIds', id))
  }

  const query = params.toString()
  return gmailFetch(userId, `/messages${query ? `?${query}` : ''}`)
}

/**
 * Get full message by ID
 */
export async function getMessage(
  userId: string,
  messageId: string,
  format: 'full' | 'metadata' | 'minimal' = 'full'
): Promise<GmailMessage> {
  return gmailFetch(userId, `/messages/${messageId}?format=${format}`)
}

/**
 * Get multiple messages by IDs (batched)
 */
export async function getMessages(
  userId: string,
  messageIds: string[],
  format: 'full' | 'metadata' | 'minimal' = 'metadata'
): Promise<GmailMessage[]> {
  // Fetch in parallel with concurrency limit
  const BATCH_SIZE = 10
  const results: GmailMessage[] = []

  for (let i = 0; i < messageIds.length; i += BATCH_SIZE) {
    const batch = messageIds.slice(i, i + BATCH_SIZE)
    const batchResults = await Promise.all(
      batch.map(id => getMessage(userId, id, format))
    )
    results.push(...batchResults)
  }

  return results
}

/**
 * List all labels
 */
export async function listLabels(userId: string): Promise<GmailLabel[]> {
  const response = await gmailFetch<{ labels: GmailLabel[] }>(userId, '/labels')
  return response.labels
}

/**
 * Parse email headers and body into a cleaner format
 */
export function parseMessage(message: GmailMessage): ParsedEmail {
  const headers = message.payload.headers
  const getHeader = (name: string) =>
    headers.find(h => h.name.toLowerCase() === name.toLowerCase())?.value || ''

  const parseAddress = (addr: string): { email: string; name?: string } => {
    // Handle "Name <email>" format
    const match = addr.match(/^(.+?)\s*<([^>]+)>$/)
    if (match) {
      return { name: match[1].trim(), email: match[2].trim() }
    }
    return { email: addr.trim() }
  }

  const parseAddressList = (value: string): Array<{ email: string; name?: string }> => {
    if (!value) return []
    return value.split(',').map(addr => parseAddress(addr.trim()))
  }

  // Find body parts
  let plainBody: string | undefined
  let htmlBody: string | undefined

  const extractBody = (payload: typeof message.payload) => {
    if (payload.body.data) {
      const decoded = Buffer.from(payload.body.data, 'base64').toString('utf-8')
      if (payload.mimeType === 'text/plain') {
        plainBody = decoded
      } else if (payload.mimeType === 'text/html') {
        htmlBody = decoded
      }
    }
    if (payload.parts) {
      payload.parts.forEach(extractBody)
    }
  }

  extractBody(message.payload)

  // Check for attachments
  const hasAttachments = (payload: typeof message.payload): boolean => {
    if (payload.filename && payload.body.attachmentId) return true
    if (payload.parts) return payload.parts.some(hasAttachments)
    return false
  }

  return {
    id: message.id,
    threadId: message.threadId,
    subject: getHeader('Subject'),
    snippet: message.snippet,
    from: parseAddress(getHeader('From')),
    to: parseAddressList(getHeader('To')),
    cc: parseAddressList(getHeader('Cc')),
    date: new Date(parseInt(message.internalDate, 10)),
    labels: message.labelIds,
    hasAttachments: hasAttachments(message.payload),
    body: plainBody || htmlBody ? { plain: plainBody, html: htmlBody } : undefined,
  }
}

/**
 * Update last sync timestamp
 */
export async function updateLastSyncTime(userId: string): Promise<void> {
  await db
    .update(oauthConnections)
    .set({
      lastSyncAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    })
    .where(
      and(
        eq(oauthConnections.userId, userId),
        eq(oauthConnections.provider, 'GOOGLE')
      )
    )
}
```

### 3. Create `/app/api/integrations/gmail/messages/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { requireUser } from '@/lib/auth/session'
import { listMessages, getMessages, parseMessage } from '@/lib/gmail/client'

export async function GET(request: NextRequest) {
  const user = await requireUser()
  const searchParams = request.nextUrl.searchParams

  const maxResults = parseInt(searchParams.get('maxResults') || '20', 10)
  const pageToken = searchParams.get('pageToken') || undefined
  const query = searchParams.get('q') || undefined

  try {
    // List message IDs
    const listResponse = await listMessages(user.id, {
      maxResults,
      pageToken,
      query,
    })

    if (!listResponse.messages || listResponse.messages.length === 0) {
      return NextResponse.json({
        messages: [],
        nextPageToken: null,
      })
    }

    // Fetch metadata for each message
    const messageIds = listResponse.messages.map(m => m.id)
    const fullMessages = await getMessages(user.id, messageIds, 'metadata')

    // Parse into cleaner format
    const parsed = fullMessages.map(parseMessage)

    return NextResponse.json({
      messages: parsed,
      nextPageToken: listResponse.nextPageToken || null,
    })
  } catch (error) {
    console.error('Gmail API error:', error)

    if (error instanceof Error && error.message.includes('reconnection required')) {
      return NextResponse.json(
        { error: 'Google reconnection required', code: 'REAUTH_REQUIRED' },
        { status: 401 }
      )
    }

    return NextResponse.json(
      { error: 'Failed to fetch messages' },
      { status: 500 }
    )
  }
}
```

### 4. Create `/app/api/integrations/gmail/messages/[messageId]/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { requireUser } from '@/lib/auth/session'
import { getMessage, parseMessage } from '@/lib/gmail/client'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ messageId: string }> }
) {
  const user = await requireUser()
  const { messageId } = await params

  try {
    const message = await getMessage(user.id, messageId, 'full')
    const parsed = parseMessage(message)

    return NextResponse.json(parsed)
  } catch (error) {
    console.error('Gmail API error:', error)
    return NextResponse.json(
      { error: 'Failed to fetch message' },
      { status: 500 }
    )
  }
}
```

## Acceptance Criteria

- [ ] Gmail client auto-refreshes expired tokens
- [ ] Token refresh failure marks connection for reauth
- [ ] Can list messages with pagination
- [ ] Can fetch individual message with full body
- [ ] Message parsing extracts: subject, from, to, cc, date, body
- [ ] Handles both plain text and HTML email bodies
- [ ] Detects attachments (doesn't download them)
- [ ] API endpoints return clean JSON format
- [ ] Errors return appropriate status codes

## Files Changed
- `lib/gmail/types.ts` (new)
- `lib/gmail/client.ts` (new)
- `app/api/integrations/gmail/messages/route.ts` (new)
- `app/api/integrations/gmail/messages/[messageId]/route.ts` (new)

## Testing

```bash
# After connecting Google account, test:
curl http://localhost:3000/api/integrations/gmail/messages?maxResults=5

# Should return JSON with messages array
```

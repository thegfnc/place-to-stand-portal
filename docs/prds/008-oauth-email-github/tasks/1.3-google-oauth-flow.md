# Task 1.3: Google OAuth Flow

## Overview
Implement the complete Google OAuth flow: initiate authorization, handle callback, store tokens, and provide disconnect functionality.

## Dependencies
- Task 1.1 (Token Encryption)
- Task 1.2 (OAuth Schema)

## Deliverables

### 1. Add environment variables to `/lib/env.server.ts`

Add to schema:
```typescript
GOOGLE_CLIENT_ID: z.string().min(1),
GOOGLE_CLIENT_SECRET: z.string().min(1),
GOOGLE_REDIRECT_URI: z.string().url(),
```

Add to parse object:
```typescript
GOOGLE_CLIENT_ID: process.env.GOOGLE_CLIENT_ID,
GOOGLE_CLIENT_SECRET: process.env.GOOGLE_CLIENT_SECRET,
GOOGLE_REDIRECT_URI: process.env.GOOGLE_REDIRECT_URI,
```

### 2. Update `.env.example`

```bash
# Google OAuth
GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=
GOOGLE_REDIRECT_URI=http://localhost:3000/api/auth/callback/google
```

### 3. Create `/lib/oauth/google.ts`

```typescript
import { serverEnv } from '@/lib/env.server'

// Phase 1 scopes - Gmail read access
export const GOOGLE_SCOPES = [
  'https://www.googleapis.com/auth/userinfo.profile',
  'https://www.googleapis.com/auth/userinfo.email',
  'https://www.googleapis.com/auth/gmail.readonly',
  'https://www.googleapis.com/auth/gmail.labels',
]

interface GoogleTokenResponse {
  access_token: string
  refresh_token?: string
  expires_in: number
  token_type: string
  scope: string
}

interface GoogleUserInfo {
  id: string
  email: string
  name?: string
  picture?: string
}

/**
 * Generate Google OAuth authorization URL
 */
export function getGoogleAuthUrl(state: string): string {
  const params = new URLSearchParams({
    client_id: serverEnv.GOOGLE_CLIENT_ID,
    redirect_uri: serverEnv.GOOGLE_REDIRECT_URI,
    response_type: 'code',
    scope: GOOGLE_SCOPES.join(' '),
    access_type: 'offline', // Required for refresh token
    prompt: 'consent', // Force consent to get refresh token
    state,
  })

  return `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`
}

/**
 * Exchange authorization code for tokens
 */
export async function exchangeCodeForTokens(code: string): Promise<GoogleTokenResponse> {
  const response = await fetch('https://oauth2.googleapis.com/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      client_id: serverEnv.GOOGLE_CLIENT_ID,
      client_secret: serverEnv.GOOGLE_CLIENT_SECRET,
      redirect_uri: serverEnv.GOOGLE_REDIRECT_URI,
      grant_type: 'authorization_code',
      code,
    }),
  })

  if (!response.ok) {
    const error = await response.text()
    throw new Error(`Token exchange failed: ${error}`)
  }

  return response.json()
}

/**
 * Refresh an access token using refresh token
 */
export async function refreshAccessToken(refreshToken: string): Promise<GoogleTokenResponse> {
  const response = await fetch('https://oauth2.googleapis.com/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      client_id: serverEnv.GOOGLE_CLIENT_ID,
      client_secret: serverEnv.GOOGLE_CLIENT_SECRET,
      grant_type: 'refresh_token',
      refresh_token: refreshToken,
    }),
  })

  if (!response.ok) {
    const error = await response.text()
    throw new Error(`Token refresh failed: ${error}`)
  }

  return response.json()
}

/**
 * Get user info from Google
 */
export async function getGoogleUserInfo(accessToken: string): Promise<GoogleUserInfo> {
  const response = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
    headers: { Authorization: `Bearer ${accessToken}` },
  })

  if (!response.ok) {
    throw new Error('Failed to get user info')
  }

  return response.json()
}

/**
 * Revoke a token (for disconnect)
 */
export async function revokeToken(token: string): Promise<void> {
  await fetch(`https://oauth2.googleapis.com/revoke?token=${token}`, {
    method: 'POST',
  })
  // Ignore errors - token may already be invalid
}
```

### 4. Create `/lib/oauth/state.ts`

```typescript
import { cookies } from 'next/headers'
import { randomBytes } from 'crypto'

const STATE_COOKIE = 'oauth_state'
const STATE_EXPIRY = 10 * 60 * 1000 // 10 minutes

/**
 * Generate and store OAuth state parameter
 */
export async function generateOAuthState(): Promise<string> {
  const state = randomBytes(32).toString('hex')
  const cookieStore = await cookies()

  cookieStore.set(STATE_COOKIE, state, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: STATE_EXPIRY / 1000,
    path: '/',
  })

  return state
}

/**
 * Validate and consume OAuth state parameter
 */
export async function validateOAuthState(state: string): Promise<boolean> {
  const cookieStore = await cookies()
  const storedState = cookieStore.get(STATE_COOKIE)?.value

  // Delete the cookie regardless of validation result
  cookieStore.delete(STATE_COOKIE)

  return storedState === state
}
```

### 5. Create `/app/api/auth/google/route.ts`

```typescript
import { NextResponse } from 'next/server'
import { requireUser } from '@/lib/auth/session'
import { getGoogleAuthUrl } from '@/lib/oauth/google'
import { generateOAuthState } from '@/lib/oauth/state'

export async function GET() {
  // Ensure user is logged in
  await requireUser()

  const state = await generateOAuthState()
  const authUrl = getGoogleAuthUrl(state)

  return NextResponse.redirect(authUrl)
}
```

### 6. Create `/app/api/auth/callback/google/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { eq, and, isNull } from 'drizzle-orm'
import { requireUser } from '@/lib/auth/session'
import { db } from '@/lib/db'
import { oauthConnections } from '@/lib/db/schema'
import { validateOAuthState } from '@/lib/oauth/state'
import {
  exchangeCodeForTokens,
  getGoogleUserInfo,
  GOOGLE_SCOPES
} from '@/lib/oauth/google'
import { encryptToken } from '@/lib/oauth/encryption'
import { logActivity } from '@/lib/activity/logger'

export async function GET(request: NextRequest) {
  const user = await requireUser()
  const searchParams = request.nextUrl.searchParams

  const code = searchParams.get('code')
  const state = searchParams.get('state')
  const error = searchParams.get('error')

  // Handle user denial
  if (error) {
    return NextResponse.redirect(
      new URL('/settings/integrations?error=access_denied', request.url)
    )
  }

  // Validate required params
  if (!code || !state) {
    return NextResponse.redirect(
      new URL('/settings/integrations?error=invalid_request', request.url)
    )
  }

  // Validate state
  const isValidState = await validateOAuthState(state)
  if (!isValidState) {
    return NextResponse.redirect(
      new URL('/settings/integrations?error=invalid_state', request.url)
    )
  }

  try {
    // Exchange code for tokens
    const tokens = await exchangeCodeForTokens(code)
    const userInfo = await getGoogleUserInfo(tokens.access_token)

    // Calculate expiry
    const expiresAt = new Date(Date.now() + tokens.expires_in * 1000).toISOString()

    // Encrypt tokens
    const encryptedAccessToken = encryptToken(tokens.access_token)
    const encryptedRefreshToken = tokens.refresh_token
      ? encryptToken(tokens.refresh_token)
      : null

    // Upsert connection (delete existing soft-deleted, insert new)
    await db.transaction(async tx => {
      // Remove any existing connection for this user+provider
      await tx
        .delete(oauthConnections)
        .where(
          and(
            eq(oauthConnections.userId, user.id),
            eq(oauthConnections.provider, 'GOOGLE')
          )
        )

      // Insert new connection
      await tx.insert(oauthConnections).values({
        userId: user.id,
        provider: 'GOOGLE',
        providerAccountId: userInfo.id,
        accessToken: encryptedAccessToken,
        refreshToken: encryptedRefreshToken,
        accessTokenExpiresAt: expiresAt,
        scopes: GOOGLE_SCOPES,
        status: 'ACTIVE',
        providerEmail: userInfo.email,
        providerMetadata: {
          name: userInfo.name,
          picture: userInfo.picture,
        },
      })
    })

    // Log activity
    await logActivity({
      actorId: user.id,
      actorRole: user.role,
      verb: 'OAUTH_CONNECTED',
      summary: `Connected Google account (${userInfo.email})`,
      targetType: 'SETTINGS',
      targetId: user.id,
      metadata: { provider: 'GOOGLE', email: userInfo.email },
    })

    return NextResponse.redirect(
      new URL('/settings/integrations?success=google_connected', request.url)
    )
  } catch (error) {
    console.error('Google OAuth error:', error)
    return NextResponse.redirect(
      new URL('/settings/integrations?error=oauth_failed', request.url)
    )
  }
}
```

### 7. Create `/app/api/integrations/google/disconnect/route.ts`

```typescript
import { NextResponse } from 'next/server'
import { eq, and } from 'drizzle-orm'
import { requireUser } from '@/lib/auth/session'
import { db } from '@/lib/db'
import { oauthConnections } from '@/lib/db/schema'
import { decryptToken } from '@/lib/oauth/encryption'
import { revokeToken } from '@/lib/oauth/google'
import { logActivity } from '@/lib/activity/logger'

export async function POST() {
  const user = await requireUser()

  // Get existing connection
  const [connection] = await db
    .select()
    .from(oauthConnections)
    .where(
      and(
        eq(oauthConnections.userId, user.id),
        eq(oauthConnections.provider, 'GOOGLE')
      )
    )
    .limit(1)

  if (!connection) {
    return NextResponse.json({ error: 'No connection found' }, { status: 404 })
  }

  // Revoke token at Google (best effort)
  try {
    const accessToken = decryptToken(connection.accessToken)
    await revokeToken(accessToken)
  } catch {
    // Continue even if revocation fails
  }

  // Delete from database
  await db
    .delete(oauthConnections)
    .where(eq(oauthConnections.id, connection.id))

  // Log activity
  await logActivity({
    actorId: user.id,
    actorRole: user.role,
    verb: 'OAUTH_DISCONNECTED',
    summary: 'Disconnected Google account',
    targetType: 'SETTINGS',
    targetId: user.id,
    metadata: { provider: 'GOOGLE' },
  })

  return NextResponse.json({ success: true })
}
```

### 8. Create `/app/api/integrations/google/status/route.ts`

```typescript
import { NextResponse } from 'next/server'
import { eq, and, isNull } from 'drizzle-orm'
import { requireUser } from '@/lib/auth/session'
import { db } from '@/lib/db'
import { oauthConnections } from '@/lib/db/schema'

export async function GET() {
  const user = await requireUser()

  const [connection] = await db
    .select({
      status: oauthConnections.status,
      providerEmail: oauthConnections.providerEmail,
      scopes: oauthConnections.scopes,
      lastSyncAt: oauthConnections.lastSyncAt,
      createdAt: oauthConnections.createdAt,
    })
    .from(oauthConnections)
    .where(
      and(
        eq(oauthConnections.userId, user.id),
        eq(oauthConnections.provider, 'GOOGLE'),
        isNull(oauthConnections.deletedAt)
      )
    )
    .limit(1)

  if (!connection) {
    return NextResponse.json({ connected: false })
  }

  return NextResponse.json({
    connected: true,
    status: connection.status,
    email: connection.providerEmail,
    scopes: connection.scopes,
    lastSyncAt: connection.lastSyncAt,
    connectedAt: connection.createdAt,
  })
}
```

### 9. Add activity verbs to `/lib/activity/logger.ts`

Add to the verbs type/enum:
```typescript
'OAUTH_CONNECTED'
'OAUTH_DISCONNECTED'
'OAUTH_REFRESHED'
'OAUTH_EXPIRED'
```

## Google Cloud Console Setup (Manual)

1. Go to https://console.cloud.google.com
2. Create new project or select existing
3. Enable APIs:
   - Gmail API
   - Google People API (for user info)
4. Configure OAuth consent screen:
   - User Type: External
   - App name, support email, developer email
   - Scopes: Add the GOOGLE_SCOPES
5. Create OAuth 2.0 Client ID:
   - Application type: Web application
   - Authorized redirect URIs:
     - `http://localhost:3000/api/auth/callback/google`
     - `https://yourdomain.com/api/auth/callback/google`

## Acceptance Criteria

- [ ] User can initiate Google OAuth from settings page
- [ ] OAuth state is validated (CSRF protection)
- [ ] Tokens are encrypted before storage
- [ ] User info (email, name) is stored
- [ ] User can disconnect Google account
- [ ] Activity is logged for connect/disconnect
- [ ] Status endpoint returns connection state
- [ ] Errors redirect with query params for UI display

## Files Changed
- `lib/env.server.ts` (modified)
- `.env.example` (modified)
- `lib/oauth/google.ts` (new)
- `lib/oauth/state.ts` (new)
- `app/api/auth/google/route.ts` (new)
- `app/api/auth/callback/google/route.ts` (new)
- `app/api/integrations/google/disconnect/route.ts` (new)
- `app/api/integrations/google/status/route.ts` (new)
- `lib/activity/logger.ts` (modified - add verbs)

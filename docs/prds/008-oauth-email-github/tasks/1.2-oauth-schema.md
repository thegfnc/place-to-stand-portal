# Task 1.2: OAuth Database Schema

## Overview
Add database tables and enums for storing OAuth connections (Google, GitHub) with encrypted tokens.

## Dependencies
- Task 1.1 (Token Encryption) must be complete

## Deliverables

### 1. Add enums to `/lib/db/schema.ts`

Add after the existing enums (around line 57):

```typescript
export const oauthProvider = pgEnum('oauth_provider', ['GOOGLE', 'GITHUB'])

export const oauthConnectionStatus = pgEnum('oauth_connection_status', [
  'ACTIVE',
  'EXPIRED',
  'REVOKED',
  'PENDING_REAUTH',
])
```

### 2. Add `oauthConnections` table to `/lib/db/schema.ts`

Add after the enums:

```typescript
export const oauthConnections = pgTable(
  'oauth_connections',
  {
    id: uuid().defaultRandom().primaryKey().notNull(),
    userId: uuid('user_id').notNull(),
    provider: oauthProvider().notNull(),
    providerAccountId: text('provider_account_id').notNull(),
    accessToken: text('access_token').notNull(), // Encrypted
    refreshToken: text('refresh_token'), // Encrypted, nullable
    accessTokenExpiresAt: timestamp('access_token_expires_at', {
      withTimezone: true,
      mode: 'string'
    }),
    scopes: text('scopes').array().notNull(),
    status: oauthConnectionStatus().default('ACTIVE').notNull(),
    providerEmail: text('provider_email'),
    providerMetadata: jsonb('provider_metadata').default({}).notNull(),
    lastSyncAt: timestamp('last_sync_at', { withTimezone: true, mode: 'string' }),
    createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' })
      .default(sql`timezone('utc'::text, now())`)
      .notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true, mode: 'string' })
      .default(sql`timezone('utc'::text, now())`)
      .notNull(),
    deletedAt: timestamp('deleted_at', { withTimezone: true, mode: 'string' }),
  },
  table => [
    // One connection per user per provider
    unique('oauth_connections_user_provider_key').on(table.userId, table.provider),
    // Index for looking up user's connections
    index('idx_oauth_connections_user')
      .using('btree', table.userId.asc().nullsLast().op('uuid_ops'))
      .where(sql`(deleted_at IS NULL)`),
    // Index for finding connections by provider
    index('idx_oauth_connections_provider')
      .using('btree', table.provider.asc().nullsLast())
      .where(sql`(deleted_at IS NULL AND status = 'ACTIVE')`),
    // Foreign key to users
    foreignKey({
      columns: [table.userId],
      foreignColumns: [users.id],
      name: 'oauth_connections_user_id_fkey',
    }).onDelete('cascade'),
  ]
)
```

### 3. Add relations to `/lib/db/relations.ts`

```typescript
import { oauthConnections } from './schema'

export const oauthConnectionsRelations = relations(oauthConnections, ({ one }) => ({
  user: one(users, {
    fields: [oauthConnections.userId],
    references: [users.id],
  }),
}))

// Also add to usersRelations if not already there:
// oauthConnections: many(oauthConnections),
```

### 4. Generate and run migration

```bash
npm run db:generate
npm run db:migrate
```

## Schema Design Notes

| Column | Purpose |
|--------|---------|
| `providerAccountId` | Google/GitHub user ID (for linking) |
| `accessToken` | Encrypted access token |
| `refreshToken` | Encrypted refresh token (Google has these, GitHub doesn't) |
| `accessTokenExpiresAt` | When token expires (for auto-refresh) |
| `scopes` | Array of granted OAuth scopes |
| `status` | Connection state (for handling revoked/expired tokens) |
| `providerEmail` | User's email on that provider |
| `providerMetadata` | Extra data (profile picture URL, etc.) |
| `lastSyncAt` | Last successful API call (for sync tracking) |

## Acceptance Criteria

- [ ] Enums created: `oauth_provider`, `oauth_connection_status`
- [ ] Table `oauth_connections` created with all columns
- [ ] Unique constraint on `(userId, provider)` - one connection per provider per user
- [ ] Foreign key to `users` table with cascade delete
- [ ] Indexes for common queries
- [ ] Migration generated and applied successfully
- [ ] Relations added to `relations.ts`

## Files Changed
- `lib/db/schema.ts` (modified - add enums and table)
- `lib/db/relations.ts` (modified - add relations)
- `drizzle/migrations/` (new migration file generated)

## Migration Details

**Migration Number:** `0007_oauth_schema.sql`

**Risk Level:** LOW - Creates new tables/enums only, no existing data affected.

## Local Migration Testing Checklist

Before deploying to production, complete this checklist:

```bash
# 1. Generate the migration
npm run db:generate -- --name oauth_schema

# 2. Review generated SQL
cat drizzle/migrations/0007_oauth_schema.sql

# 3. Apply to LOCAL Supabase database
DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54322/postgres npm run db:migrate
```

### Verification Steps

```sql
-- Check table exists with correct structure
\d oauth_connections

-- Check enums created correctly
SELECT enum_range(NULL::oauth_provider);
SELECT enum_range(NULL::oauth_connection_status);

-- Verify indexes exist
\di+ idx_oauth_connections_*

-- Test unique constraint
INSERT INTO oauth_connections (user_id, provider, provider_account_id, access_token, scopes)
VALUES ('00000000-0000-0000-0000-000000000001', 'GOOGLE', 'test123', 'enc_token', ARRAY['email']);
-- Second insert with same user+provider should fail:
INSERT INTO oauth_connections (user_id, provider, provider_account_id, access_token, scopes)
VALUES ('00000000-0000-0000-0000-000000000001', 'GOOGLE', 'test456', 'enc_token2', ARRAY['email']);
-- Expected: unique constraint violation

-- Clean up test data
DELETE FROM oauth_connections WHERE provider_account_id LIKE 'test%';
```

### Rollback Plan

If issues occur:
```sql
DROP TABLE IF EXISTS oauth_connections CASCADE;
DROP TYPE IF EXISTS oauth_connection_status;
DROP TYPE IF EXISTS oauth_provider;
```

Then remove the migration file and re-run `db:generate`.

# Task 2.1: Client Contacts Database Schema

## Overview
Add a database table to store external email addresses associated with clients. This enables automatic email-to-client matching.

## Dependencies
- Task 1.2 (OAuth Schema) - ensures schema patterns are established

## Deliverables

### 1. Add `clientContacts` table to `/lib/db/schema.ts`

Add after the `clients` table definition:

```typescript
export const clientContacts = pgTable(
  'client_contacts',
  {
    id: uuid().defaultRandom().primaryKey().notNull(),
    clientId: uuid('client_id').notNull(),
    email: text().notNull(),
    name: text(),
    isPrimary: boolean('is_primary').default(false).notNull(),
    createdBy: uuid('created_by'),
    createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' })
      .default(sql`timezone('utc'::text, now())`)
      .notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true, mode: 'string' })
      .default(sql`timezone('utc'::text, now())`)
      .notNull(),
    deletedAt: timestamp('deleted_at', { withTimezone: true, mode: 'string' }),
  },
  table => [
    // One email per client (prevent duplicates)
    unique('client_contacts_client_email_key').on(table.clientId, table.email),
    // Index for looking up contacts by client
    index('idx_client_contacts_client')
      .using('btree', table.clientId.asc().nullsLast().op('uuid_ops'))
      .where(sql`(deleted_at IS NULL)`),
    // Index for email matching (critical for performance)
    index('idx_client_contacts_email')
      .using('btree', table.email.asc().nullsLast().op('text_ops'))
      .where(sql`(deleted_at IS NULL)`),
    // Index for looking up by email domain (for domain matching)
    index('idx_client_contacts_email_domain')
      .using('btree', sql`split_part(email, '@', 2)`)
      .where(sql`(deleted_at IS NULL)`),
    // Foreign key to clients
    foreignKey({
      columns: [table.clientId],
      foreignColumns: [clients.id],
      name: 'client_contacts_client_id_fkey',
    }).onDelete('cascade'),
    // Foreign key to users (who created)
    foreignKey({
      columns: [table.createdBy],
      foreignColumns: [users.id],
      name: 'client_contacts_created_by_fkey',
    }),
    // RLS Policies
    pgPolicy('Admins manage client contacts', {
      as: 'permissive',
      for: 'all',
      to: ['public'],
      using: sql`is_admin()`,
    }),
    pgPolicy('Users view client contacts for accessible clients', {
      as: 'permissive',
      for: 'select',
      to: ['public'],
      using: sql`(
        client_id IN (
          SELECT client_id FROM client_members
          WHERE user_id = auth.uid() AND deleted_at IS NULL
        )
      )`,
    }),
  ]
)
```

### 2. Add relations to `/lib/db/relations.ts`

```typescript
import { clientContacts } from './schema'

export const clientContactsRelations = relations(clientContacts, ({ one }) => ({
  client: one(clients, {
    fields: [clientContacts.clientId],
    references: [clients.id],
  }),
  createdByUser: one(users, {
    fields: [clientContacts.createdBy],
    references: [users.id],
  }),
}))

// Update clientsRelations to add:
// contacts: many(clientContacts),
```

### 3. Create TypeScript types in `/lib/types/client-contacts.ts`

```typescript
import type { InferSelectModel, InferInsertModel } from 'drizzle-orm'
import type { clientContacts } from '@/lib/db/schema'

export type ClientContact = InferSelectModel<typeof clientContacts>
export type NewClientContact = InferInsertModel<typeof clientContacts>

export interface ClientContactWithClient extends ClientContact {
  client: {
    id: string
    name: string
    slug: string | null
  }
}
```

### 4. Generate and run migration

```bash
npm run db:generate
npm run db:migrate
```

## Schema Design Notes

| Column | Purpose |
|--------|---------|
| `clientId` | Links contact to a client |
| `email` | Contact's email address (lowercase, validated) |
| `name` | Contact's display name (optional) |
| `isPrimary` | Whether this is the main contact for the client |
| `createdBy` | User who added this contact |

## Why This Design

1. **Email index**: Fast lookup when matching incoming emails
2. **Domain index**: Enables domain-based matching (e.g., all @acme.com emails â†’ Acme client)
3. **Unique constraint**: Prevents duplicate emails per client
4. **Soft delete**: Maintains audit trail
5. **RLS policies**: Admins manage all, users can view for their clients

## Acceptance Criteria

- [ ] Table `client_contacts` created with all columns
- [ ] Unique constraint on `(clientId, email)`
- [ ] Index on `email` column for fast matching
- [ ] Index on email domain for domain matching
- [ ] Foreign key to `clients` with cascade delete
- [ ] Foreign key to `users` for `createdBy`
- [ ] RLS policies for admin/user access
- [ ] Relations added
- [ ] Migration generated and applied
- [ ] TypeScript types exported

## Files Changed
- `lib/db/schema.ts` (modified - add table)
- `lib/db/relations.ts` (modified - add relations)
- `lib/types/client-contacts.ts` (new)
- `drizzle/migrations/` (new migration file)

## Migration Details

**Migration Number:** `0008_client_contacts.sql`

**Risk Level:** LOW - Creates new table only, no existing data affected.

## Local Migration Testing Checklist

Before deploying to production, complete this checklist:

```bash
# 1. Generate the migration
npm run db:generate -- --name client_contacts

# 2. Review generated SQL
cat drizzle/migrations/0008_client_contacts.sql

# 3. Apply to LOCAL Supabase database
DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54322/postgres npm run db:migrate
```

### Verification Steps

```sql
-- Verify table structure
\d client_contacts

-- Verify indexes (including expression index on domain)
\di+ idx_client_contacts_*

-- Test unique constraint
INSERT INTO client_contacts (client_id, email)
VALUES ('00000000-0000-0000-0000-000000000001', 'test@example.com');
-- Second insert with same client+email should fail:
INSERT INTO client_contacts (client_id, email)
VALUES ('00000000-0000-0000-0000-000000000001', 'test@example.com');
-- Expected: unique constraint violation

-- Test domain index works for queries
EXPLAIN SELECT * FROM client_contacts WHERE split_part(email, '@', 2) = 'example.com';
-- Should show index scan on idx_client_contacts_email_domain

-- Clean up test data
DELETE FROM client_contacts WHERE email LIKE 'test@%';
```

### Rollback Plan

If issues occur:
```sql
DROP TABLE IF EXISTS client_contacts CASCADE;
```

Then remove the migration file and re-run `db:generate`.

# Task 3.2: Email Analysis AI Service

## Overview
Create the AI service that analyzes emails and extracts actionable tasks using the existing Vercel AI Gateway + Gemini setup.

## Dependencies
- Task 3.1 (Task Suggestions Schema)

## Deliverables

### 1. Create `/lib/ai/prompts/email-to-tasks.ts`

```typescript
export const EMAIL_ANALYSIS_SYSTEM_PROMPT = `You are an AI assistant for a professional services agency called Place to Stand. Your job is to analyze client emails and extract actionable tasks.

## Context About the Agency
- We manage client projects with tasks, time tracking, and deliverables
- Tasks have: title, description, due date, priority, assignees
- Priorities: HIGH (urgent/blocking), MEDIUM (important/scheduled), LOW (nice-to-have)

## When Analyzing Emails
1. Identify explicit requests or action items directed at the agency
2. Extract implicit deliverables mentioned that require work
3. Note any deadlines or time-sensitive elements
4. Consider the email's tone and urgency level
5. One email may contain multiple distinct tasks

## Task Extraction Rules
- Be specific and actionable in task titles (start with verb)
- Include relevant context in descriptions
- Only suggest due dates if explicitly mentioned or clearly implied
- Assign confidence scores based on clarity of the request:
  - 0.9-1.0: Explicit, clear request with specific deliverable
  - 0.7-0.8: Clear intent but some ambiguity
  - 0.5-0.6: Implied task, requires interpretation
  - Below 0.5: Don't suggest (too uncertain)

## DO NOT Create Tasks For
- General FYIs or status updates (no action required)
- Things the SENDER will do themselves
- Meeting confirmations (unless there's prep work)
- Thank you messages
- Auto-generated notifications

## Output Format
Return a JSON object with:
- tasks: Array of extracted tasks
- noActionRequired: Boolean if email doesn't need tasks
- summary: Brief explanation of your analysis`

export const EMAIL_ANALYSIS_USER_PROMPT = (params: {
  subject: string
  body: string
  fromEmail: string
  fromName?: string
  receivedAt: string
  clientName?: string
  projectName?: string
  recentTasks?: string[]
}) => `
## Email to Analyze

**From:** ${params.fromName ? `${params.fromName} <${params.fromEmail}>` : params.fromEmail}
**Date:** ${params.receivedAt}
**Subject:** ${params.subject}

**Body:**
${params.body}

${params.clientName ? `## Context\n**Client:** ${params.clientName}` : ''}
${params.projectName ? `**Project:** ${params.projectName}` : ''}
${params.recentTasks?.length ? `\n**Recent tasks in this project:**\n${params.recentTasks.map(t => `- ${t}`).join('\n')}` : ''}

Please analyze this email and extract any actionable tasks.`
```

### 2. Create `/lib/ai/schemas/task-extraction.ts`

```typescript
import { z } from 'zod'

export const extractedTaskSchema = z.object({
  title: z.string().max(200).describe('Actionable task title starting with a verb'),
  description: z.string().max(2000).optional().describe('Additional context and details'),
  dueDate: z.string().date().optional().describe('Due date if mentioned (YYYY-MM-DD)'),
  priority: z.enum(['HIGH', 'MEDIUM', 'LOW']).optional().describe('Task priority'),
  confidence: z.number().min(0).max(1).describe('Confidence score 0-1'),
  reasoning: z.string().max(500).describe('Brief explanation of why this is a task'),
})

export const emailAnalysisResultSchema = z.object({
  tasks: z.array(extractedTaskSchema),
  noActionRequired: z.boolean(),
  summary: z.string().max(500),
})

export type ExtractedTask = z.infer<typeof extractedTaskSchema>
export type EmailAnalysisResult = z.infer<typeof emailAnalysisResultSchema>
```

### 3. Create `/lib/ai/email-analysis.ts`

```typescript
import { generateObject } from 'ai'
import { createOpenAI } from '@ai-sdk/openai'
import { serverEnv } from '@/lib/env.server'
import { EMAIL_ANALYSIS_SYSTEM_PROMPT, EMAIL_ANALYSIS_USER_PROMPT } from './prompts/email-to-tasks'
import { emailAnalysisResultSchema, type EmailAnalysisResult } from './schemas/task-extraction'

// Use Vercel AI Gateway (same setup as activity summary)
const aiGateway = createOpenAI({
  baseURL: 'https://gateway.ai.cloudflare.com/v1/anthropic',
  apiKey: serverEnv.AI_GATEWAY_API_KEY,
})

const MODEL = 'google/gemini-2.5-flash-lite'

interface AnalyzeEmailParams {
  subject: string
  body: string
  fromEmail: string
  fromName?: string
  receivedAt: string
  clientName?: string
  projectName?: string
  recentTasks?: string[]
}

interface AnalysisResponse {
  result: EmailAnalysisResult
  usage: {
    promptTokens: number
    completionTokens: number
  }
}

/**
 * Analyze an email and extract actionable tasks
 */
export async function analyzeEmailForTasks(
  params: AnalyzeEmailParams
): Promise<AnalysisResponse> {
  const userPrompt = EMAIL_ANALYSIS_USER_PROMPT(params)

  const { object, usage } = await generateObject({
    model: aiGateway(MODEL),
    system: EMAIL_ANALYSIS_SYSTEM_PROMPT,
    prompt: userPrompt,
    schema: emailAnalysisResultSchema,
  })

  return {
    result: object,
    usage: {
      promptTokens: usage?.promptTokens ?? 0,
      completionTokens: usage?.completionTokens ?? 0,
    },
  }
}

/**
 * Filter tasks by minimum confidence threshold
 */
export function filterByConfidence(
  tasks: EmailAnalysisResult['tasks'],
  minConfidence: number = 0.5
): EmailAnalysisResult['tasks'] {
  return tasks.filter(task => task.confidence >= minConfidence)
}
```

### 4. Create `/lib/ai/suggestion-service.ts`

```typescript
import { eq, and, isNull, desc } from 'drizzle-orm'
import { db } from '@/lib/db'
import { taskSuggestions, emailMetadata, emailLinks, clients, projects, tasks } from '@/lib/db/schema'
import { analyzeEmailForTasks, filterByConfidence } from './email-analysis'
import { getMessage, parseMessage } from '@/lib/gmail/client'
import type { NewTaskSuggestion } from '@/lib/types/suggestions'

const MODEL_VERSION = 'gemini-2.5-flash-lite-v1'
const MIN_CONFIDENCE = 0.5

/**
 * Analyze a single email and create task suggestions
 */
export async function createSuggestionsFromEmail(
  emailId: string,
  userId: string
): Promise<{ created: number; skipped: boolean }> {
  // Get email metadata
  const [email] = await db
    .select()
    .from(emailMetadata)
    .where(
      and(
        eq(emailMetadata.id, emailId),
        eq(emailMetadata.userId, userId),
        isNull(emailMetadata.deletedAt)
      )
    )
    .limit(1)

  if (!email) {
    throw new Error('Email not found')
  }

  // Check if already analyzed
  const existing = await db
    .select({ id: taskSuggestions.id })
    .from(taskSuggestions)
    .where(
      and(
        eq(taskSuggestions.emailMetadataId, emailId),
        isNull(taskSuggestions.deletedAt)
      )
    )
    .limit(1)

  if (existing.length > 0) {
    return { created: 0, skipped: true }
  }

  // Get email body from Gmail
  const gmailMessage = await getMessage(userId, email.gmailMessageId, 'full')
  const parsed = parseMessage(gmailMessage)

  if (!parsed.body?.plain && !parsed.body?.html) {
    // No body to analyze
    return { created: 0, skipped: true }
  }

  // Get linked client/project context
  const [link] = await db
    .select({
      clientId: emailLinks.clientId,
      clientName: clients.name,
      projectId: emailLinks.projectId,
      projectName: projects.name,
    })
    .from(emailLinks)
    .leftJoin(clients, eq(clients.id, emailLinks.clientId))
    .leftJoin(projects, eq(projects.id, emailLinks.projectId))
    .where(
      and(
        eq(emailLinks.emailMetadataId, emailId),
        isNull(emailLinks.deletedAt)
      )
    )
    .limit(1)

  // Get recent tasks if we have a project
  let recentTasks: string[] = []
  if (link?.projectId) {
    const recent = await db
      .select({ title: tasks.title })
      .from(tasks)
      .where(
        and(
          eq(tasks.projectId, link.projectId),
          isNull(tasks.deletedAt)
        )
      )
      .orderBy(desc(tasks.createdAt))
      .limit(10)
    recentTasks = recent.map(t => t.title)
  }

  // Analyze with AI
  const { result, usage } = await analyzeEmailForTasks({
    subject: email.subject || '',
    body: parsed.body.plain || parsed.body.html || '',
    fromEmail: email.fromEmail,
    fromName: email.fromName || undefined,
    receivedAt: email.receivedAt,
    clientName: link?.clientName || undefined,
    projectName: link?.projectName || undefined,
    recentTasks,
  })

  // Filter and create suggestions
  const validTasks = filterByConfidence(result.tasks, MIN_CONFIDENCE)

  if (validTasks.length === 0) {
    return { created: 0, skipped: false }
  }

  const suggestions: NewTaskSuggestion[] = validTasks.map(task => ({
    emailMetadataId: emailId,
    projectId: link?.projectId || null,
    suggestedTitle: task.title,
    suggestedDescription: task.description || null,
    suggestedDueDate: task.dueDate || null,
    suggestedPriority: task.priority || null,
    suggestedAssignees: [],
    confidence: String(task.confidence),
    reasoning: task.reasoning,
    status: 'PENDING' as const,
    aiModelVersion: MODEL_VERSION,
    promptTokens: Math.round(usage.promptTokens / validTasks.length),
    completionTokens: Math.round(usage.completionTokens / validTasks.length),
  }))

  await db.insert(taskSuggestions).values(suggestions)

  return { created: suggestions.length, skipped: false }
}

/**
 * Process all unanalyzed emails for a user
 */
export async function processUnanalyzedEmails(
  userId: string,
  limit: number = 50
): Promise<{ processed: number; created: number }> {
  // Find emails without suggestions
  const unanalyzed = await db
    .select({ id: emailMetadata.id })
    .from(emailMetadata)
    .leftJoin(
      taskSuggestions,
      and(
        eq(taskSuggestions.emailMetadataId, emailMetadata.id),
        isNull(taskSuggestions.deletedAt)
      )
    )
    .where(
      and(
        eq(emailMetadata.userId, userId),
        isNull(emailMetadata.deletedAt),
        isNull(taskSuggestions.id)
      )
    )
    .limit(limit)

  let created = 0
  for (const { id } of unanalyzed) {
    try {
      const result = await createSuggestionsFromEmail(id, userId)
      created += result.created
    } catch (error) {
      console.error(`Failed to analyze email ${id}:`, error)
    }
  }

  return { processed: unanalyzed.length, created }
}
```

### 5. Create `/app/api/emails/[emailId]/analyze/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { requireRole } from '@/lib/auth/session'
import { createSuggestionsFromEmail } from '@/lib/ai/suggestion-service'

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ emailId: string }> }
) {
  const user = await requireRole('ADMIN')
  const { emailId } = await params

  try {
    const result = await createSuggestionsFromEmail(emailId, user.id)

    return NextResponse.json({
      success: true,
      created: result.created,
      skipped: result.skipped,
    })
  } catch (error) {
    console.error('Email analysis error:', error)
    return NextResponse.json(
      { error: 'Analysis failed' },
      { status: 500 }
    )
  }
}
```

### 6. Add activity verbs to `/lib/activity/logger.ts`

```typescript
'TASK_SUGGESTION_CREATED'
'TASK_SUGGESTION_APPROVED'
'TASK_SUGGESTION_REJECTED'
'TASK_CREATED_FROM_EMAIL'
```

## AI Model Configuration

The service uses the same Vercel AI Gateway setup as the existing activity summary feature:
- Model: `google/gemini-2.5-flash-lite`
- Uses `generateObject` for structured output
- Schema validation with Zod

## Acceptance Criteria

- [ ] System prompt correctly guides task extraction
- [ ] User prompt includes email content and context
- [ ] Zod schema validates AI output
- [ ] Tasks filtered by minimum confidence (0.5)
- [ ] Suggestions created in database
- [ ] Token usage tracked per suggestion
- [ ] Email body fetched from Gmail on-demand
- [ ] Client/project context included when available
- [ ] Recent tasks provided to avoid duplicates
- [ ] API endpoint triggers analysis

## Files Changed
- `lib/ai/prompts/email-to-tasks.ts` (new)
- `lib/ai/schemas/task-extraction.ts` (new)
- `lib/ai/email-analysis.ts` (new)
- `lib/ai/suggestion-service.ts` (new)
- `app/api/emails/[emailId]/analyze/route.ts` (new)
- `lib/activity/logger.ts` (modified)

## Testing

1. Link an email to a client
2. Call analyze endpoint: `POST /api/emails/{emailId}/analyze`
3. Check task_suggestions table for created records
4. Verify confidence scores and reasoning

# Task 4.1: GitHub OAuth Integration

## Overview
Implement GitHub OAuth flow to allow users to connect their GitHub accounts, enabling repo access for PR creation.

## Dependencies
- Task 1.2 (OAuth Schema) - uses same oauth_connections table

## Deliverables

### 1. Add environment variables to `/lib/env.server.ts`

Add to schema:
```typescript
GITHUB_CLIENT_ID: z.string().min(1),
GITHUB_CLIENT_SECRET: z.string().min(1),
GITHUB_REDIRECT_URI: z.string().url(),
```

Add to parse object:
```typescript
GITHUB_CLIENT_ID: process.env.GITHUB_CLIENT_ID,
GITHUB_CLIENT_SECRET: process.env.GITHUB_CLIENT_SECRET,
GITHUB_REDIRECT_URI: process.env.GITHUB_REDIRECT_URI,
```

### 2. Update `.env.example`

```bash
# GitHub OAuth
GITHUB_CLIENT_ID=
GITHUB_CLIENT_SECRET=
GITHUB_REDIRECT_URI=http://localhost:3000/api/auth/callback/github
```

### 3. Create `/lib/oauth/github.ts`

```typescript
import { serverEnv } from '@/lib/env.server'

// Scopes for GitHub access
export const GITHUB_SCOPES = [
  'repo',        // Full access to repositories
  'read:user',   // Read user profile
  'user:email',  // Access user email
  'read:org',    // Read org memberships
]

interface GitHubTokenResponse {
  access_token: string
  token_type: string
  scope: string
}

interface GitHubUser {
  id: number
  login: string
  email: string | null
  name: string | null
  avatar_url: string
}

/**
 * Generate GitHub OAuth authorization URL
 */
export function getGitHubAuthUrl(state: string): string {
  const params = new URLSearchParams({
    client_id: serverEnv.GITHUB_CLIENT_ID,
    redirect_uri: serverEnv.GITHUB_REDIRECT_URI,
    scope: GITHUB_SCOPES.join(' '),
    state,
  })

  return `https://github.com/login/oauth/authorize?${params.toString()}`
}

/**
 * Exchange authorization code for access token
 */
export async function exchangeGitHubCodeForToken(code: string): Promise<GitHubTokenResponse> {
  const response = await fetch('https://github.com/login/oauth/access_token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    },
    body: JSON.stringify({
      client_id: serverEnv.GITHUB_CLIENT_ID,
      client_secret: serverEnv.GITHUB_CLIENT_SECRET,
      code,
    }),
  })

  if (!response.ok) {
    throw new Error('Failed to exchange GitHub code for token')
  }

  const data = await response.json()

  if (data.error) {
    throw new Error(data.error_description || data.error)
  }

  return data
}

/**
 * Get GitHub user info
 */
export async function getGitHubUser(accessToken: string): Promise<GitHubUser> {
  const response = await fetch('https://api.github.com/user', {
    headers: {
      Authorization: `Bearer ${accessToken}`,
      Accept: 'application/vnd.github.v3+json',
    },
  })

  if (!response.ok) {
    throw new Error('Failed to get GitHub user')
  }

  return response.json()
}

/**
 * Get user's primary email if not public
 */
export async function getGitHubUserEmail(accessToken: string): Promise<string | null> {
  const response = await fetch('https://api.github.com/user/emails', {
    headers: {
      Authorization: `Bearer ${accessToken}`,
      Accept: 'application/vnd.github.v3+json',
    },
  })

  if (!response.ok) {
    return null
  }

  const emails = await response.json()
  const primary = emails.find((e: any) => e.primary && e.verified)

  return primary?.email || null
}

/**
 * Revoke GitHub token (delete authorization)
 */
export async function revokeGitHubToken(accessToken: string): Promise<void> {
  // GitHub doesn't have a simple revoke endpoint
  // The token will remain valid until user revokes from GitHub settings
  // or the OAuth app is removed
  // Best practice: just delete from our database
}
```

### 4. Create `/app/api/auth/github/route.ts`

```typescript
import { NextResponse } from 'next/server'
import { requireUser } from '@/lib/auth/session'
import { getGitHubAuthUrl } from '@/lib/oauth/github'
import { generateOAuthState } from '@/lib/oauth/state'

export async function GET() {
  await requireUser()

  const state = await generateOAuthState()
  const authUrl = getGitHubAuthUrl(state)

  return NextResponse.redirect(authUrl)
}
```

### 5. Create `/app/api/auth/callback/github/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { eq, and } from 'drizzle-orm'
import { requireUser } from '@/lib/auth/session'
import { db } from '@/lib/db'
import { oauthConnections } from '@/lib/db/schema'
import { validateOAuthState } from '@/lib/oauth/state'
import {
  exchangeGitHubCodeForToken,
  getGitHubUser,
  getGitHubUserEmail,
  GITHUB_SCOPES,
} from '@/lib/oauth/github'
import { encryptToken } from '@/lib/oauth/encryption'
import { logActivity } from '@/lib/activity/logger'

export async function GET(request: NextRequest) {
  const user = await requireUser()
  const searchParams = request.nextUrl.searchParams

  const code = searchParams.get('code')
  const state = searchParams.get('state')
  const error = searchParams.get('error')

  // Handle user denial
  if (error) {
    return NextResponse.redirect(
      new URL('/settings/integrations?error=github_access_denied', request.url)
    )
  }

  // Validate params
  if (!code || !state) {
    return NextResponse.redirect(
      new URL('/settings/integrations?error=github_invalid_request', request.url)
    )
  }

  // Validate state
  const isValidState = await validateOAuthState(state)
  if (!isValidState) {
    return NextResponse.redirect(
      new URL('/settings/integrations?error=github_invalid_state', request.url)
    )
  }

  try {
    // Exchange code for token
    const tokenResponse = await exchangeGitHubCodeForToken(code)
    const githubUser = await getGitHubUser(tokenResponse.access_token)

    // Get email if not public
    let email = githubUser.email
    if (!email) {
      email = await getGitHubUserEmail(tokenResponse.access_token)
    }

    // Encrypt token
    const encryptedToken = encryptToken(tokenResponse.access_token)

    // Upsert connection
    await db.transaction(async tx => {
      // Remove existing
      await tx
        .delete(oauthConnections)
        .where(
          and(
            eq(oauthConnections.userId, user.id),
            eq(oauthConnections.provider, 'GITHUB')
          )
        )

      // Insert new
      await tx.insert(oauthConnections).values({
        userId: user.id,
        provider: 'GITHUB',
        providerAccountId: String(githubUser.id),
        accessToken: encryptedToken,
        refreshToken: null, // GitHub doesn't use refresh tokens
        accessTokenExpiresAt: null, // GitHub tokens don't expire
        scopes: GITHUB_SCOPES,
        status: 'ACTIVE',
        providerEmail: email,
        providerMetadata: {
          login: githubUser.login,
          name: githubUser.name,
          avatar_url: githubUser.avatar_url,
        },
      })
    })

    // Log activity
    await logActivity({
      actorId: user.id,
      actorRole: user.role,
      verb: 'OAUTH_CONNECTED',
      summary: `Connected GitHub account (@${githubUser.login})`,
      targetType: 'SETTINGS',
      targetId: user.id,
      metadata: { provider: 'GITHUB', login: githubUser.login },
    })

    return NextResponse.redirect(
      new URL('/settings/integrations?success=github_connected', request.url)
    )
  } catch (error) {
    console.error('GitHub OAuth error:', error)
    return NextResponse.redirect(
      new URL('/settings/integrations?error=github_oauth_failed', request.url)
    )
  }
}
```

### 6. Create `/app/api/integrations/github/disconnect/route.ts`

```typescript
import { NextResponse } from 'next/server'
import { eq, and } from 'drizzle-orm'
import { requireUser } from '@/lib/auth/session'
import { db } from '@/lib/db'
import { oauthConnections } from '@/lib/db/schema'
import { logActivity } from '@/lib/activity/logger'

export async function POST() {
  const user = await requireUser()

  // Get connection
  const [connection] = await db
    .select()
    .from(oauthConnections)
    .where(
      and(
        eq(oauthConnections.userId, user.id),
        eq(oauthConnections.provider, 'GITHUB')
      )
    )
    .limit(1)

  if (!connection) {
    return NextResponse.json({ error: 'No connection found' }, { status: 404 })
  }

  // Delete from database
  await db
    .delete(oauthConnections)
    .where(eq(oauthConnections.id, connection.id))

  // Log activity
  await logActivity({
    actorId: user.id,
    actorRole: user.role,
    verb: 'OAUTH_DISCONNECTED',
    summary: 'Disconnected GitHub account',
    targetType: 'SETTINGS',
    targetId: user.id,
    metadata: { provider: 'GITHUB' },
  })

  return NextResponse.json({ success: true })
}
```

### 7. Create `/app/api/integrations/github/status/route.ts`

```typescript
import { NextResponse } from 'next/server'
import { eq, and, isNull } from 'drizzle-orm'
import { requireUser } from '@/lib/auth/session'
import { db } from '@/lib/db'
import { oauthConnections } from '@/lib/db/schema'

export async function GET() {
  const user = await requireUser()

  const [connection] = await db
    .select({
      status: oauthConnections.status,
      providerEmail: oauthConnections.providerEmail,
      providerMetadata: oauthConnections.providerMetadata,
      scopes: oauthConnections.scopes,
      createdAt: oauthConnections.createdAt,
    })
    .from(oauthConnections)
    .where(
      and(
        eq(oauthConnections.userId, user.id),
        eq(oauthConnections.provider, 'GITHUB'),
        isNull(oauthConnections.deletedAt)
      )
    )
    .limit(1)

  if (!connection) {
    return NextResponse.json({ connected: false })
  }

  const metadata = connection.providerMetadata as { login?: string; name?: string; avatar_url?: string }

  return NextResponse.json({
    connected: true,
    status: connection.status,
    email: connection.providerEmail,
    login: metadata.login,
    name: metadata.name,
    avatarUrl: metadata.avatar_url,
    scopes: connection.scopes,
    connectedAt: connection.createdAt,
  })
}
```

### 8. Update integrations UI

Update `/app/(dashboard)/settings/integrations/integrations-panel.tsx` to handle GitHub:

```typescript
// Add to the GitHub card section:
const handleGitHubConnect = () => {
  window.location.href = '/api/auth/github'
}

const handleGitHubDisconnect = async () => {
  setDisconnecting('github')
  try {
    const response = await fetch('/api/integrations/github/disconnect', {
      method: 'POST',
    })

    if (!response.ok) throw new Error('Failed to disconnect')

    toast({
      title: 'Disconnected',
      description: 'GitHub account has been disconnected.',
    })

    router.refresh()
  } catch (error) {
    toast({
      title: 'Error',
      description: 'Failed to disconnect GitHub account.',
      variant: 'destructive',
    })
  } finally {
    setDisconnecting(null)
  }
}
```

## GitHub OAuth App Setup (Manual)

1. Go to https://github.com/settings/developers
2. Click "New OAuth App"
3. Fill in:
   - Application name: "Place to Stand Portal"
   - Homepage URL: Your app URL
   - Authorization callback URL: `https://yourdomain.com/api/auth/callback/github`
4. Save Client ID and generate Client Secret
5. Add to environment variables

## Acceptance Criteria

- [ ] User can initiate GitHub OAuth
- [ ] OAuth state validated
- [ ] Token encrypted and stored
- [ ] User info (login, email, avatar) stored
- [ ] Can disconnect GitHub account
- [ ] Status endpoint returns connection info
- [ ] Activity logged for connect/disconnect
- [ ] UI updated to show GitHub status

## Files Changed
- `lib/env.server.ts` (modified)
- `.env.example` (modified)
- `lib/oauth/github.ts` (new)
- `app/api/auth/github/route.ts` (new)
- `app/api/auth/callback/github/route.ts` (new)
- `app/api/integrations/github/disconnect/route.ts` (new)
- `app/api/integrations/github/status/route.ts` (new)
- `app/(dashboard)/settings/integrations/integrations-panel.tsx` (modified)

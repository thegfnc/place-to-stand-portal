# Task 2.3: Email Metadata Database Schema

## Overview
Add database tables for storing email metadata (not full content) and email-to-client/project links.

## Dependencies
- Task 1.2 (OAuth Schema)

## Deliverables

### 1. Add enum to `/lib/db/schema.ts`

```typescript
export const emailLinkSource = pgEnum('email_link_source', [
  'AUTOMATIC',      // System detected from client contacts
  'MANUAL_FORWARD', // User forwarded email
  'MANUAL_LINK',    // User manually linked via UI
])
```

### 2. Add `emailMetadata` table to `/lib/db/schema.ts`

```typescript
export const emailMetadata = pgTable(
  'email_metadata',
  {
    id: uuid().defaultRandom().primaryKey().notNull(),
    userId: uuid('user_id').notNull(), // PTS user who owns this email
    gmailMessageId: text('gmail_message_id').notNull(),
    gmailThreadId: text('gmail_thread_id'),
    subject: text(),
    snippet: text(), // Gmail's preview text
    fromEmail: text('from_email').notNull(),
    fromName: text('from_name'),
    toEmails: text('to_emails').array().default([]).notNull(),
    ccEmails: text('cc_emails').array().default([]).notNull(),
    receivedAt: timestamp('received_at', { withTimezone: true, mode: 'string' }).notNull(),
    isRead: boolean('is_read').default(false).notNull(),
    hasAttachments: boolean('has_attachments').default(false).notNull(),
    labels: text().array().default([]).notNull(),
    rawMetadata: jsonb('raw_metadata').default({}).notNull(),
    createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' })
      .default(sql`timezone('utc'::text, now())`)
      .notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true, mode: 'string' })
      .default(sql`timezone('utc'::text, now())`)
      .notNull(),
    deletedAt: timestamp('deleted_at', { withTimezone: true, mode: 'string' }),
  },
  table => [
    // Unique: one entry per Gmail message per user
    unique('email_metadata_user_gmail_id_key').on(table.userId, table.gmailMessageId),
    // Index for user's emails
    index('idx_email_metadata_user')
      .using('btree', table.userId.asc().nullsLast().op('uuid_ops'))
      .where(sql`(deleted_at IS NULL)`),
    // Index for from email (for matching)
    index('idx_email_metadata_from_email')
      .using('btree', table.fromEmail.asc().nullsLast().op('text_ops'))
      .where(sql`(deleted_at IS NULL)`),
    // Index for date range queries
    index('idx_email_metadata_received_at')
      .using('btree', table.receivedAt.desc().nullsFirst())
      .where(sql`(deleted_at IS NULL)`),
    // Index for thread grouping
    index('idx_email_metadata_thread')
      .using('btree', table.gmailThreadId.asc().nullsLast().op('text_ops'))
      .where(sql`(deleted_at IS NULL AND gmail_thread_id IS NOT NULL)`),
    // Foreign key
    foreignKey({
      columns: [table.userId],
      foreignColumns: [users.id],
      name: 'email_metadata_user_id_fkey',
    }).onDelete('cascade'),
    // RLS Policies
    pgPolicy('Users manage own email metadata', {
      as: 'permissive',
      for: 'all',
      to: ['public'],
      using: sql`user_id = auth.uid()`,
    }),
    pgPolicy('Admins view all email metadata', {
      as: 'permissive',
      for: 'select',
      to: ['public'],
      using: sql`is_admin()`,
    }),
  ]
)
```

### 3. Add `emailLinks` table to `/lib/db/schema.ts`

```typescript
export const emailLinks = pgTable(
  'email_links',
  {
    id: uuid().defaultRandom().primaryKey().notNull(),
    emailMetadataId: uuid('email_metadata_id').notNull(),
    clientId: uuid('client_id'), // Nullable - can link to just project
    projectId: uuid('project_id'), // Nullable - can link to just client
    source: emailLinkSource().notNull(),
    confidence: numeric({ precision: 3, scale: 2 }), // 0.00-1.00 for automatic (CHECK constraint enforces range)
    linkedBy: uuid('linked_by'), // Null for automatic links
    notes: text(),
    createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' })
      .default(sql`timezone('utc'::text, now())`)
      .notNull(),
    updatedAt: timestamp('updated_at', { withTimezone: true, mode: 'string' })
      .default(sql`timezone('utc'::text, now())`)
      .notNull(),
    deletedAt: timestamp('deleted_at', { withTimezone: true, mode: 'string' }),
  },
  table => [
    // Index for email lookup
    index('idx_email_links_email')
      .using('btree', table.emailMetadataId.asc().nullsLast().op('uuid_ops'))
      .where(sql`(deleted_at IS NULL)`),
    // Index for client lookup
    index('idx_email_links_client')
      .using('btree', table.clientId.asc().nullsLast().op('uuid_ops'))
      .where(sql`(deleted_at IS NULL AND client_id IS NOT NULL)`),
    // Index for project lookup
    index('idx_email_links_project')
      .using('btree', table.projectId.asc().nullsLast().op('uuid_ops'))
      .where(sql`(deleted_at IS NULL AND project_id IS NOT NULL)`),
    // Constraint: must link to at least client OR project
    check(
      'email_links_client_or_project',
      sql`client_id IS NOT NULL OR project_id IS NOT NULL`
    ),
    // Constraint: confidence must be between 0 and 1
    check(
      'email_links_confidence_range',
      sql`confidence IS NULL OR (confidence >= 0 AND confidence <= 1)`
    ),
    // Foreign keys
    foreignKey({
      columns: [table.emailMetadataId],
      foreignColumns: [emailMetadata.id],
      name: 'email_links_email_metadata_id_fkey',
    }).onDelete('cascade'),
    foreignKey({
      columns: [table.clientId],
      foreignColumns: [clients.id],
      name: 'email_links_client_id_fkey',
    }).onDelete('cascade'),
    foreignKey({
      columns: [table.projectId],
      foreignColumns: [projects.id],
      name: 'email_links_project_id_fkey',
    }).onDelete('cascade'),
    foreignKey({
      columns: [table.linkedBy],
      foreignColumns: [users.id],
      name: 'email_links_linked_by_fkey',
    }),
    // RLS Policies
    pgPolicy('Admins manage email links', {
      as: 'permissive',
      for: 'all',
      to: ['public'],
      using: sql`is_admin()`,
    }),
    pgPolicy('Users view linked emails for accessible clients', {
      as: 'permissive',
      for: 'select',
      to: ['public'],
      using: sql`(
        client_id IN (
          SELECT client_id FROM client_members
          WHERE user_id = auth.uid() AND deleted_at IS NULL
        )
        OR project_id IN (
          SELECT id FROM projects
          WHERE created_by = auth.uid() AND deleted_at IS NULL
        )
      )`,
    }),
  ]
)
```

### 4. Add relations to `/lib/db/relations.ts`

```typescript
import { emailMetadata, emailLinks } from './schema'

export const emailMetadataRelations = relations(emailMetadata, ({ one, many }) => ({
  user: one(users, {
    fields: [emailMetadata.userId],
    references: [users.id],
  }),
  links: many(emailLinks),
}))

export const emailLinksRelations = relations(emailLinks, ({ one }) => ({
  email: one(emailMetadata, {
    fields: [emailLinks.emailMetadataId],
    references: [emailMetadata.id],
  }),
  client: one(clients, {
    fields: [emailLinks.clientId],
    references: [clients.id],
  }),
  project: one(projects, {
    fields: [emailLinks.projectId],
    references: [projects.id],
  }),
  linkedByUser: one(users, {
    fields: [emailLinks.linkedBy],
    references: [users.id],
  }),
}))
```

### 5. Create TypeScript types in `/lib/types/emails.ts`

```typescript
import type { InferSelectModel, InferInsertModel } from 'drizzle-orm'
import type { emailMetadata, emailLinks } from '@/lib/db/schema'

export type EmailMetadata = InferSelectModel<typeof emailMetadata>
export type NewEmailMetadata = InferInsertModel<typeof emailMetadata>

export type EmailLink = InferSelectModel<typeof emailLinks>
export type NewEmailLink = InferInsertModel<typeof emailLinks>

export type EmailLinkSource = 'AUTOMATIC' | 'MANUAL_FORWARD' | 'MANUAL_LINK'

export interface EmailWithLinks extends EmailMetadata {
  links: Array<{
    id: string
    source: EmailLinkSource
    confidence: string | null
    client: { id: string; name: string } | null
    project: { id: string; name: string } | null
  }>
}
```

### 6. Generate and run migration

```bash
npm run db:generate
npm run db:migrate
```

## Schema Design Notes

### emailMetadata Table
| Column | Purpose |
|--------|---------|
| `userId` | Which PTS user's Gmail this came from |
| `gmailMessageId` | Gmail's unique message ID (for fetching full content) |
| `gmailThreadId` | Thread grouping |
| `subject`, `snippet` | Display without API call |
| `fromEmail`, `fromName` | Sender info (for matching) |
| `toEmails`, `ccEmails` | Recipients (arrays) |
| `receivedAt` | When email was received |
| `isRead`, `hasAttachments`, `labels` | Gmail metadata |
| `rawMetadata` | Additional Gmail data (JSONB) |

### emailLinks Table
| Column | Purpose |
|--------|---------|
| `emailMetadataId` | Which email this links |
| `clientId` | Linked client (nullable) |
| `projectId` | Linked project (nullable) |
| `source` | How the link was created |
| `confidence` | For automatic links: 0.00-1.00 |
| `linkedBy` | User who created manual link |
| `notes` | Optional notes |

### Why This Design

1. **Separation of metadata and links**: Email can link to multiple clients/projects
2. **Confidence score**: Track reliability of automatic matches
3. **Source tracking**: Know if link was automatic or manual
4. **No full content**: Store only metadata, fetch body from Gmail when needed
5. **Thread support**: Can group by thread for conversation view

## Acceptance Criteria

- [ ] Enum `email_link_source` created
- [ ] Table `email_metadata` created with all columns
- [ ] Table `email_links` created with all columns
- [ ] Check constraint: links must have client OR project
- [ ] All indexes created
- [ ] All foreign keys with appropriate cascade rules
- [ ] RLS policies for access control
- [ ] Relations added
- [ ] TypeScript types exported
- [ ] Migration generated and applied

## Files Changed
- `lib/db/schema.ts` (modified - add enum and tables)
- `lib/db/relations.ts` (modified - add relations)
- `lib/types/emails.ts` (new)
- `drizzle/migrations/` (new migration file)

## Migration Details

**Migration Number:** `0009_email_metadata.sql`

**Risk Level:** LOW - Creates new tables/enum only, no existing data affected.

## Local Migration Testing Checklist

Before deploying to production, complete this checklist:

```bash
# 1. Generate the migration
npm run db:generate -- --name email_metadata

# 2. Review generated SQL
cat drizzle/migrations/0009_email_metadata.sql

# 3. Apply to LOCAL Supabase database
DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54322/postgres npm run db:migrate
```

### Verification Steps

```sql
-- Verify tables
\d email_metadata
\d email_links

-- Verify enum
SELECT enum_range(NULL::email_link_source);

-- Verify indexes
\di+ idx_email_metadata_*
\di+ idx_email_links_*

-- Test CHECK constraint: must have client OR project
INSERT INTO email_links (email_metadata_id, source)
VALUES ('00000000-0000-0000-0000-000000000001', 'MANUAL_LINK');
-- Expected: check constraint "email_links_client_or_project" violated

-- Test CHECK constraint: confidence must be 0-1
INSERT INTO email_links (email_metadata_id, client_id, source, confidence)
VALUES ('00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-000000000002', 'AUTOMATIC', 1.50);
-- Expected: check constraint "email_links_confidence_range" violated

-- Test with valid data
INSERT INTO email_links (email_metadata_id, client_id, source, confidence)
VALUES ('00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-000000000002', 'AUTOMATIC', 0.85);
-- Expected: success

-- Clean up
DELETE FROM email_links WHERE confidence = 0.85;
```

### Rollback Plan

If issues occur:
```sql
DROP TABLE IF EXISTS email_links CASCADE;
DROP TABLE IF EXISTS email_metadata CASCADE;
DROP TYPE IF EXISTS email_link_source;
```

Then remove the migration file and re-run `db:generate`.

### Future Consideration: Partitioning

If `email_metadata` grows large (100k+ rows), consider partitioning by `receivedAt`:
```sql
-- Future optimization, not needed initially
CREATE TABLE email_metadata (...) PARTITION BY RANGE (received_at);
```

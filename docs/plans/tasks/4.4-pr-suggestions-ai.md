# Task 4.4: PR Suggestions AI Service

## Overview
Create the AI service that generates PR descriptions from emails/tasks, using the existing Gemini setup.

## Dependencies
- Task 3.2 (Email Analysis AI) - reuses AI patterns
- Task 4.2 (GitHub Repo Schema)

## Deliverables

### 1. Create `/lib/ai/prompts/email-to-pr.ts`

```typescript
export const PR_GENERATION_SYSTEM_PROMPT = `You are an AI assistant for a professional services agency. Your job is to generate GitHub Pull Request descriptions based on email discussions and task requirements.

## Output Requirements
Generate professional PR descriptions with:
1. A clear, concise title following conventional commits format when appropriate
2. A comprehensive body with:
   - Summary of what the PR accomplishes
   - Context/motivation from the email discussion
   - Implementation approach (if discernible)
   - Testing suggestions
   - Any breaking changes or important notes

## Guidelines
- Be technical and professional
- Focus on the "what" and "why"
- Use markdown formatting
- Keep titles under 72 characters
- Include relevant context from the email
- Suggest branch names following kebab-case convention

## PR Title Conventions
- feat: new feature
- fix: bug fix
- docs: documentation
- refactor: code refactoring
- test: adding tests
- chore: maintenance tasks`

export const PR_GENERATION_USER_PROMPT = (params: {
  emailSubject: string
  emailBody: string
  fromEmail: string
  repoFullName: string
  projectName?: string
  relatedTaskTitle?: string
  relatedTaskDescription?: string
}) => `
## Generate PR for Repository: ${params.repoFullName}
${params.projectName ? `**Project:** ${params.projectName}` : ''}

## Source Email
**From:** ${params.fromEmail}
**Subject:** ${params.emailSubject}

**Body:**
${params.emailBody}

${params.relatedTaskTitle ? `
## Related Task
**Title:** ${params.relatedTaskTitle}
${params.relatedTaskDescription ? `**Description:** ${params.relatedTaskDescription}` : ''}
` : ''}

Please generate a PR title, description, and suggested branch name based on this email and context.`
```

### 2. Create `/lib/ai/schemas/pr-generation.ts`

```typescript
import { z } from 'zod'

export const generatedPRSchema = z.object({
  title: z.string().max(100).describe('PR title, optionally with conventional commit prefix'),
  body: z.string().max(10000).describe('Markdown-formatted PR description'),
  suggestedBranch: z.string().max(100).optional().describe('Suggested feature branch name'),
  labels: z.array(z.string()).optional().describe('Suggested PR labels'),
  confidence: z.number().min(0).max(1).describe('Confidence in the suggestion'),
  reasoning: z.string().max(500).describe('Brief explanation of the PR focus'),
})

export type GeneratedPR = z.infer<typeof generatedPRSchema>
```

### 3. Create `/lib/ai/pr-generation.ts`

```typescript
import { generateObject } from 'ai'
import { createOpenAI } from '@ai-sdk/openai'
import { serverEnv } from '@/lib/env.server'
import { PR_GENERATION_SYSTEM_PROMPT, PR_GENERATION_USER_PROMPT } from './prompts/email-to-pr'
import { generatedPRSchema, type GeneratedPR } from './schemas/pr-generation'

const aiGateway = createOpenAI({
  baseURL: 'https://gateway.ai.cloudflare.com/v1/anthropic',
  apiKey: serverEnv.AI_GATEWAY_API_KEY,
})

const MODEL = 'google/gemini-2.5-flash-lite'

interface GeneratePRParams {
  emailSubject: string
  emailBody: string
  fromEmail: string
  repoFullName: string
  projectName?: string
  relatedTaskTitle?: string
  relatedTaskDescription?: string
}

export async function generatePRSuggestion(
  params: GeneratePRParams
): Promise<{ result: GeneratedPR; promptTokens: number; completionTokens: number }> {
  const userPrompt = PR_GENERATION_USER_PROMPT(params)

  const { object, usage } = await generateObject({
    model: aiGateway(MODEL),
    system: PR_GENERATION_SYSTEM_PROMPT,
    prompt: userPrompt,
    schema: generatedPRSchema,
  })

  return {
    result: object,
    promptTokens: usage?.promptTokens ?? 0,
    completionTokens: usage?.completionTokens ?? 0,
  }
}
```

### 4. Create `/lib/ai/pr-suggestion-service.ts`

```typescript
import { eq, and, isNull } from 'drizzle-orm'
import { db } from '@/lib/db'
import {
  prSuggestions,
  githubRepoLinks,
  emailMetadata,
  taskSuggestions,
  projects,
} from '@/lib/db/schema'
import { getMessage, parseMessage } from '@/lib/gmail/client'
import { generatePRSuggestion } from './pr-generation'
import type { NewPRSuggestion, PRSuggestionWithContext } from '@/lib/types/github'

const MODEL_VERSION = 'gemini-2.5-flash-lite-v1'

/**
 * Create a PR suggestion from an email
 */
export async function createPRSuggestionFromEmail(
  emailId: string,
  repoLinkId: string,
  userId: string
): Promise<PRSuggestionWithContext> {
  // Get email
  const [email] = await db
    .select()
    .from(emailMetadata)
    .where(
      and(
        eq(emailMetadata.id, emailId),
        isNull(emailMetadata.deletedAt)
      )
    )
    .limit(1)

  if (!email) throw new Error('Email not found')

  // Get repo link
  const [repoLink] = await db
    .select({
      link: githubRepoLinks,
      projectName: projects.name,
    })
    .from(githubRepoLinks)
    .leftJoin(projects, eq(projects.id, githubRepoLinks.projectId))
    .where(eq(githubRepoLinks.id, repoLinkId))
    .limit(1)

  if (!repoLink) throw new Error('Repo link not found')

  // Get email body from Gmail
  const gmailMessage = await getMessage(userId, email.gmailMessageId, 'full')
  const parsed = parseMessage(gmailMessage)
  const emailBody = parsed.body?.plain || parsed.body?.html || ''

  // Generate suggestion
  const { result, promptTokens, completionTokens } = await generatePRSuggestion({
    emailSubject: email.subject || '',
    emailBody,
    fromEmail: email.fromEmail,
    repoFullName: repoLink.link.repoFullName,
    projectName: repoLink.projectName || undefined,
  })

  // Save suggestion
  const [suggestion] = await db
    .insert(prSuggestions)
    .values({
      emailMetadataId: emailId,
      githubRepoLinkId: repoLinkId,
      suggestedTitle: result.title,
      suggestedBody: result.body,
      suggestedBranch: result.suggestedBranch,
      suggestedBaseBranch: repoLink.link.defaultBranch,
      suggestedLabels: result.labels || [],
      suggestedAssignees: [],
      confidence: String(result.confidence),
      reasoning: result.reasoning,
      status: 'DRAFT',
      aiModelVersion: MODEL_VERSION,
    })
    .returning()

  return {
    ...suggestion,
    repoLink: {
      repoFullName: repoLink.link.repoFullName,
      defaultBranch: repoLink.link.defaultBranch,
    },
    email: {
      subject: email.subject,
      fromEmail: email.fromEmail,
    },
  }
}

/**
 * Create a PR suggestion from an approved task suggestion
 */
export async function createPRSuggestionFromTask(
  taskSuggestionId: string,
  repoLinkId: string,
  userId: string
): Promise<PRSuggestionWithContext> {
  // Get task suggestion with email
  const [taskSuggestion] = await db
    .select({
      suggestion: taskSuggestions,
      email: emailMetadata,
    })
    .from(taskSuggestions)
    .innerJoin(emailMetadata, eq(emailMetadata.id, taskSuggestions.emailMetadataId))
    .where(eq(taskSuggestions.id, taskSuggestionId))
    .limit(1)

  if (!taskSuggestion) throw new Error('Task suggestion not found')

  // Get repo link
  const [repoLink] = await db
    .select({
      link: githubRepoLinks,
      projectName: projects.name,
    })
    .from(githubRepoLinks)
    .leftJoin(projects, eq(projects.id, githubRepoLinks.projectId))
    .where(eq(githubRepoLinks.id, repoLinkId))
    .limit(1)

  if (!repoLink) throw new Error('Repo link not found')

  // Get email body
  const gmailMessage = await getMessage(userId, taskSuggestion.email.gmailMessageId, 'full')
  const parsed = parseMessage(gmailMessage)
  const emailBody = parsed.body?.plain || parsed.body?.html || ''

  // Generate suggestion with task context
  const { result, promptTokens, completionTokens } = await generatePRSuggestion({
    emailSubject: taskSuggestion.email.subject || '',
    emailBody,
    fromEmail: taskSuggestion.email.fromEmail,
    repoFullName: repoLink.link.repoFullName,
    projectName: repoLink.projectName || undefined,
    relatedTaskTitle: taskSuggestion.suggestion.suggestedTitle,
    relatedTaskDescription: taskSuggestion.suggestion.suggestedDescription || undefined,
  })

  // Save suggestion
  const [suggestion] = await db
    .insert(prSuggestions)
    .values({
      taskSuggestionId,
      emailMetadataId: taskSuggestion.email.id,
      githubRepoLinkId: repoLinkId,
      suggestedTitle: result.title,
      suggestedBody: result.body,
      suggestedBranch: result.suggestedBranch,
      suggestedBaseBranch: repoLink.link.defaultBranch,
      suggestedLabels: result.labels || [],
      suggestedAssignees: [],
      confidence: String(result.confidence),
      reasoning: result.reasoning,
      status: 'DRAFT',
      aiModelVersion: MODEL_VERSION,
    })
    .returning()

  return {
    ...suggestion,
    repoLink: {
      repoFullName: repoLink.link.repoFullName,
      defaultBranch: repoLink.link.defaultBranch,
    },
    email: {
      subject: taskSuggestion.email.subject,
      fromEmail: taskSuggestion.email.fromEmail,
    },
  }
}
```

### 5. Create `/app/api/emails/[emailId]/generate-pr/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'
import { requireRole } from '@/lib/auth/session'
import { createPRSuggestionFromEmail } from '@/lib/ai/pr-suggestion-service'

const schema = z.object({
  repoLinkId: z.string().uuid(),
})

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ emailId: string }> }
) {
  const user = await requireRole('ADMIN')
  const { emailId } = await params

  const body = await request.json()
  const result = schema.safeParse(body)

  if (!result.success) {
    return NextResponse.json({ error: 'Invalid request' }, { status: 400 })
  }

  try {
    const suggestion = await createPRSuggestionFromEmail(
      emailId,
      result.data.repoLinkId,
      user.id
    )

    return NextResponse.json({ success: true, suggestion })
  } catch (error) {
    console.error('PR generation error:', error)
    return NextResponse.json(
      { error: 'Failed to generate PR suggestion' },
      { status: 500 }
    )
  }
}
```

### 6. Create `/app/api/suggestions/[suggestionId]/generate-pr/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { z } from 'zod'
import { requireRole } from '@/lib/auth/session'
import { createPRSuggestionFromTask } from '@/lib/ai/pr-suggestion-service'

const schema = z.object({
  repoLinkId: z.string().uuid(),
})

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ suggestionId: string }> }
) {
  const user = await requireRole('ADMIN')
  const { suggestionId } = await params

  const body = await request.json()
  const result = schema.safeParse(body)

  if (!result.success) {
    return NextResponse.json({ error: 'Invalid request' }, { status: 400 })
  }

  try {
    const prSuggestion = await createPRSuggestionFromTask(
      suggestionId,
      result.data.repoLinkId,
      user.id
    )

    return NextResponse.json({ success: true, suggestion: prSuggestion })
  } catch (error) {
    console.error('PR generation error:', error)
    return NextResponse.json(
      { error: 'Failed to generate PR suggestion' },
      { status: 500 }
    )
  }
}
```

### 7. Add activity verbs to `/lib/activity/logger.ts`

```typescript
'PR_SUGGESTION_CREATED'
'PR_SUGGESTION_APPROVED'
'PR_SUGGESTION_REJECTED'
'PR_CREATED_FROM_SUGGESTION'
```

## Acceptance Criteria

- [ ] System prompt guides PR generation
- [ ] Can generate PR from email
- [ ] Can generate PR from task suggestion
- [ ] Includes task context when available
- [ ] Suggestions stored in database
- [ ] Confidence score assigned
- [ ] Suggested branch name generated
- [ ] API endpoints work correctly

## Files Changed
- `lib/ai/prompts/email-to-pr.ts` (new)
- `lib/ai/schemas/pr-generation.ts` (new)
- `lib/ai/pr-generation.ts` (new)
- `lib/ai/pr-suggestion-service.ts` (new)
- `app/api/emails/[emailId]/generate-pr/route.ts` (new)
- `app/api/suggestions/[suggestionId]/generate-pr/route.ts` (new)
- `lib/activity/logger.ts` (modified)

## Testing

1. Link email to client with project that has linked repo
2. Call: `POST /api/emails/{emailId}/generate-pr` with `{ repoLinkId: "..." }`
3. Verify PR suggestion created with title, body, branch name
4. Test from task suggestion as well
